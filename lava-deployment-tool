#!/bin/bash
LAVA_DEPLOYMENT_TOOL_VERSION="0.5"

# Global Configuration

# Where all LAVA stuff is kept, this is meant to make /srv/lava extensible in the future
LAVA_ROOT=/srv/lava

# All LAVA instances are created relative to this path
LAVA_PREFIX=$LAVA_ROOT/instances

# Deploy revisions of this branch
LAVA_MANIFEST_BRANCH="${LAVA_MANIFEST_BRANCH-lp:lava-manifest}"
# Use this buildout config file from $LAVA_MANIFEST_BRANCH
LAVA_BUILDOUT_CFG="${LAVA_BUILDOUT_CFG-buildout.cfg}"

# Where to cache the eggs and downloads for buildbot
LAVA_EGG_CACHE=$LAVA_ROOT/.cache/eggs
LAVA_DOWNLOAD_CACHE=$LAVA_ROOT/.cache/download-cache

# All LAVA uses this python version
LAVA_PYTHON=python2.6

# All of LAVA is being served by this uWSGI version
LAVA_UWSGI=1.0.3

# Current version of setup required by lava (global state)
export LAVA_SETUP_REQUIRED_VERSION=23

# Check if this installation is supported
export LAVA_SUPPORTED=0

# Installation and configuration steps (all the wizard_xxx install_xxx functions)
LAVA_INSTALL_STEPS="user fs buildout database broker web_hosting app config_app"

# Will cause Django to be run with DEBUG enabled.
LAVA_DEV_MODE=no

# If set to yes no questions will be asked and default values will be used
LAVA_NON_INTERACTIVE=no

os_check() {
    case `lsb_release -i -s` in
        Ubuntu)
            case `lsb_release -c -s` in
                lucid)
                    export LAVA_PYTHON=python2.6
                    # FIXME: Lucid is not supported
                    export LAVA_SUPPORTED=0
                    # Required system packages
                    LAVA_PKG_LIST="whiptail python-virtualenv python-pip git-core build-essential $LAVA_PYTHON-dev libxml2-dev apache2 apache2-dev postgresql rabbitmq-server mercurial conmux linaro-image-tools"
                    ;;
                oneiric|precise)
                    export LAVA_PYTHON=python2.7
                    export LAVA_SUPPORTED=1
                    LAVA_PKG_LIST="whiptail python-virtualenv python-pip git build-essential $LAVA_PYTHON-dev libxml2-dev apache2 apache2-dev postgresql rabbitmq-server mercurial conmux linaro-image-tools unzip bzr"
                    ;;
                quantal)
                    #apache2-dev is no longer available. use apache2-threaded-dev instead.
                    #see http://changelogs.ubuntu.com/changelogs/pool/main/a/apache2/apache2_2.2.22-6ubuntu2/changelog
                    export LAVA_PYTHON=python2.7
                    export LAVA_SUPPORTED=1
                    LAVA_PKG_LIST="whiptail python-virtualenv python-pip git build-essential $LAVA_PYTHON-dev libxml2-dev apache2 apache2-threaded-dev postgresql rabbitmq-server mercurial conmux linaro-image-tools unzip bzr"
                    ;;
            esac
            ;;
    esac
}


uid_check() {
    if [ $(id -u) = 0 ]; then
        echo "Running as root is not supported"
        exit 1
    fi
}

_read_input() {
    prompt="$1"
    varname="$2"
    default_value="$3"
    if [ "$LAVA_NON_INTERACTIVE" = yes ]; then
        if [ -n "$default_value" ]; then
            eval "$varname='$default_value'"
        fi
    else
        local _response
        read -p "$prompt" _response
        if [ -z "$_response" -a -n "$default_value" ]; then
            eval "$varname='$default_value'"
        else
            eval "$varname='$_response'"
        fi
    fi
}


_load_configuration() {
    LAVA_INSTANCE=$1

    # Persistent config
    if [ -e $LAVA_PREFIX/$LAVA_INSTANCE/instance.conf ]; then
        . $LAVA_PREFIX/$LAVA_INSTANCE/instance.conf
        # TODO: ensure we have all essential variables or we die verbosely
    else
        # Legacy configs, no lava- prefix
        export LAVA_SYS_USER=$LAVA_INSTANCE
        export LAVA_DB_USER=$LAVA_INSTANCE
        export LAVA_DB_NAME=$LAVA_INSTANCE
        # Single static vhost
        export LAVA_RABBIT_VHOST=/
    fi

    export LAVA_SYS_USER
    export LAVA_DB_USER
    export LAVA_DB_NAME
    export LAVA_RABBIT_VHOST
}


_show_config() {
    cat <<INSTANCE_CONF
# Installation prefix
LAVA_PREFIX='$LAVA_PREFIX'
# Instance name
LAVA_INSTANCE='$LAVA_INSTANCE'
# The lava-server branch used by upgrade
LAVA_MANIFEST_BRANCH='$LAVA_MANIFEST_BRANCH'
LAVA_BUILDOUT_CFG='$LAVA_BUILDOUT_CFG'
# System configuration (Unix-level)
LAVA_SYS_USER='$LAVA_SYS_USER'
# Apache configuration
LAVA_APACHE_VHOST='$LAVA_APACHE_VHOST'
LAVA_DEV_MODE='$LAVA_DEV_MODE'
# PostgreSQL configuration
LAVA_DB_NAME='$LAVA_DB_NAME'
LAVA_DB_USER='$LAVA_DB_USER'
LAVA_DB_PASSWORD='$LAVA_DB_PASSWORD'
# RabbitMQ configuration
LAVA_RABBIT_VHOST='$LAVA_RABBIT_VHOST'
LAVA_RABBIT_USER='$LAVA_RABBIT_USER'
LAVA_RABBIT_PASSWORD='$LAVA_RABBIT_PASSWORD'
# Scheduler configuration
LAVA_SCHEDULER_ENABLED='$LAVA_SCHEDULER_ENABLED'
LAVA_SERVER_IP='$LAVA_SERVER_IP'
LAVA_PROXY='$LAVA_PROXY'
INSTANCE_CONF
}


_save_config() {
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/
    _show_config >$LAVA_PREFIX/$LAVA_INSTANCE/instance.conf
}


_configure() {
    set +x
    export LAVA_INSTANCE="$1"
    # Defaults
    for install_step in $LAVA_INSTALL_STEPS; do
        defaults_$install_step
    done
    # Wizard loop
    while true; do
        echo "Instance Configuration"
        echo "----------------------"
        echo
        echo "Before configuring your instance we need to ask you a few questions"
        echo "The defaults are safe so feel free to use them without any changes"
        # Wizard page loop
        num_steps=1
        for install_step in $LAVA_INSTALL_STEPS; do
            while true; do
                echo
                echo "Note: it is safe to CTRL-C at this stage!"
                wizard_$install_step && break
            done
        done
        echo
        echo "Configuration summary"
        echo "---------------------"
        echo
        _show_config
        echo
        # Response loop
        while true; do
            echo "(it is safe to CTRL-C at this stage!)"
            _read_input "Is everything okay? (yes|no) [yes]: " RESPONSE yes
            case "$RESPONSE" in
                yes|no)
                    break
                    ;;
            esac
        done
        if [ "$RESPONSE" = "yes" ]; then
            echo "Saving configuration"
            _save_config
            echo "Configuration done"
            break
        else
            echo "Going back to wizard"
            continue
        fi
    done
    set -x
}


_install() {
    for install_step in $LAVA_INSTALL_STEPS; do 
        echo "Running installation step $install_step"
        install_$install_step
    done
    echo "All installation is done"
}


defaults_user() {
    export LAVA_SYS_USER=lava-$LAVA_INSTANCE
}


wizard_user() {
    export LAVA_SYS_USER_DESC="User for LAVA instance $LAVA_INSTANCE"

    echo
    echo "User account configuration"
    echo "^^^^^^^^^^^^^^^^^^^^^^^^^^"
    echo
    echo "We need to create a system user for this instance:"
    echo "System user account configuration"
    echo
    echo "User name:        '$LAVA_SYS_USER'"
    echo "User description: '$LAVA_SYS_USER_DESC'"
    echo
    echo "next   - Use the user name as is"
    echo "edit   - Edit the user name"

    _read_input "Please please decide what to do [next]: " RESPONSE next

    case "$RESPONSE" in
        next)
            return 0  # loop complete
            ;;
        edit)
            _read_input "New user name: " LAVA_SYS_USER_NEW
            if test -n "$LAVA_SYS_USER_NEW" && echo "$LAVA_SYS_USER_NEW" | grep -q -E -e '[a-z]+[-a-z0-9]*'; then
                echo "New user name is '$LAVA_SYS_USER_NEW'"
                LAVA_SYS_USER="$LAVA_SYS_USER_NEW" 
            else
                echo "Incorrect user name. It must be a simple ascii identifier"
            fi
            ;;
    esac
    return 1  # another loop please
}


install_user() {
    logger "Creating system user for LAVA instance $LAVA_INSTANCE: $LAVA_SYS_USER"
    echo "Creating system user for LAVA instance $LAVA_INSTANCE: $LAVA_SYS_USER"
    sudo useradd --system --comment "$LAVA_SYS_USER_DESC" "$LAVA_SYS_USER"
}


defaults_fs() {
    true
}


wizard_fs() {
    echo
    echo "Filesystem configuration"
    echo "^^^^^^^^^^^^^^^^^^^^^^^^"
    echo
    echo "We need filesystem location for this instance"
    echo
    echo "Installation directory: $LAVA_PREFIX/$LAVA_INSTANCE"
    echo
    echo "Note: everything apart from the database and message"
    echo "broker state will be stored there"
    echo
    echo "(this is just a notification, it is not configurable)"
    echo
    echo "next    - continue"

    _read_input "Please decide what to do [next]: " RESPONSE next

    case "$RESPONSE" in
        next)
            return 0  # loop complete
    esac
    return 1  # another loop please
}


install_fs() {
    logger "Creating filesystem structure for LAVA instance $LAVA_INSTANCE"
    # Create basic directory structure
    # Apache application:
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/etc/apache2/conf.d
    # Apache site:
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/etc/apache2/sites-available
    # Dispatcher configuration 
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-dispatcher
    # Dashboard reports
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/reports
    # Dashboard data views
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/views
    # Custom templates
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/templates
    # Static file cache
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/var/www/lava-server/static
    # Lava-dispatcher folders
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/var/cache/lava-dispatcher
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/var/www/lava-server/images
    # Repository of precious user-generated data (needs backup)
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/var/lib/lava-server/media
    # Celery state 
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/var/lib/lava-celery
    # Log files
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/var/log
    # Sockets and other runtime stuff
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/run
    # Temporary files
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/tmp

    # For buildout
    bzr init-repo $LAVA_PREFIX/$LAVA_INSTANCE/code
    ln -s $LAVA_PREFIX/$LAVA_INSTANCE/code/current/bin $LAVA_PREFIX/$LAVA_INSTANCE

    # Allow apache (running as www-data) to read our public web files 
    sudo chgrp -R www-data $LAVA_PREFIX/$LAVA_INSTANCE/var/www/lava-server/
    sudo chmod -R g+rXs $LAVA_PREFIX/$LAVA_INSTANCE/var/www/lava-server/
    # Allow instance user to read all lava-server settings
    sudo chgrp -R $LAVA_SYS_USER $LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server
    sudo chmod -R g+rXs $LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/
    # Allow instance to write to media directory
    sudo chgrp -R $LAVA_SYS_USER $LAVA_PREFIX/$LAVA_INSTANCE/var/lib/lava-server/
    sudo chmod -R g+rwXs $LAVA_PREFIX/$LAVA_INSTANCE/var/lib/lava-server/
    # Prevent anyone else from reading from the media directory
    sudo chmod -R o-rX $LAVA_PREFIX/$LAVA_INSTANCE/var/lib/lava-server/
    # Allow instance to store lava-celery state 
    sudo chgrp -R $LAVA_SYS_USER $LAVA_PREFIX/$LAVA_INSTANCE/var/lib/lava-celery/
    sudo chmod -R g+rwXs $LAVA_PREFIX/$LAVA_INSTANCE/var/lib/lava-celery/
    # Allow instance user to put stuff in runtime directory
    # and allow www-data to read from that directory
    sudo chown -R $LAVA_SYS_USER:www-data $LAVA_PREFIX/$LAVA_INSTANCE/run
    sudo chmod -R g+rXs $LAVA_PREFIX/$LAVA_INSTANCE/run
    # Allow instance to log stuff to log directory
    # Allow users in the adm group to read those logs
    sudo chown -R $LAVA_SYS_USER:adm $LAVA_PREFIX/$LAVA_INSTANCE/var/log
    sudo chmod -R g+rXs $LAVA_PREFIX/$LAVA_INSTANCE/var/log
    # Allow instance user to put stuff in temporary directory
    # Set the sticky and setgid bits there
    sudo chgrp -R $LAVA_SYS_USER $LAVA_PREFIX/$LAVA_INSTANCE/tmp
    sudo chmod -R g+rwtXs $LAVA_PREFIX/$LAVA_INSTANCE/tmp
}


defaults_buildout () {
    true
}

wizard_buildout () {
    true
}

install_buildout () {
    set -xe
    local venv="$LAVA_PREFIX/$LAVA_INSTANCE/var/lib/bootstrap-venv"
    if [ $(virtualenv --version) '<' '1.7' ]; then
        virtualenv --no-site-packages "${venv}"
    else
        virtualenv "${venv}"
    fi
    "${venv}/bin/pip" install \
        $LAVA_DOWNLOAD_CACHE/dist/distribute-0.6.24.tar.gz \
        $LAVA_DOWNLOAD_CACHE/dist/zc.buildout-1.5.2.tar.gz \
        $LAVA_DOWNLOAD_CACHE/dist/uwsgi-$LAVA_UWSGI.tar.gz \
        $LAVA_DOWNLOAD_CACHE/dist/bzr-2.5.1.tar.gz
    set +xe
}

defaults_database() {
    export LAVA_DB_NAME="lava-$LAVA_INSTANCE"
    export LAVA_DB_USER="lava-$LAVA_INSTANCE"
    export LAVA_DB_PASSWORD=$(dd if=/dev/urandom bs=1 count=128 2>/dev/null | md5sum | cut -d ' ' -f 1)
}


wizard_database() {
    echo
    echo "PostgreSQL configuration"
    echo "^^^^^^^^^^^^^^^^^^^^^^^^"
    echo
    echo "We will use PostgreSQL to store application state"
    echo "(apart from files that are just files in your filesystem)"
    echo
    echo "Database name: $LAVA_DB_NAME"
    echo "Database user: $LAVA_DB_USER"
    echo "     password: $LAVA_DB_PASSWORD (automatically generated)"
    echo
    echo "(this is just a notification, it is not configurable)"
    echo
    echo "next    - continue"

    _read_input "Please decide what to do [next]: " RESPONSE next

    case "$RESPONSE" in
        next)
            return 0  # loop complete
    esac
    return 1  # another loop please
}


install_database()
{
    logger "Creating database configuration for LAVA instance $LAVA_INSTANCE"

    # Create database configuration file
    cat >$LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/default_database.conf <<DEFAULT_DATABASE_CONF
dbuser='$LAVA_DB_USER'
dbpass='$LAVA_DB_PASSWORD'
basepath=''
dbname='$LAVA_DB_NAME'
dbserver=''
dbport=''
dbtype='pgsql'
DEFAULT_DATABASE_CONF

    # Create database user
    sudo -u postgres createuser \
        --no-createdb \
        --encrypted \
        --login \
        --no-superuser \
        --no-createrole \
        --no-password \
        "$LAVA_DB_USER" \
        || die "Failed to create database user"

    # Set a password for our new user
    sudo -u postgres psql \
        --quiet \
        --command="ALTER USER \"$LAVA_DB_USER\" WITH PASSWORD '$LAVA_DB_PASSWORD'" \
        || die "Failed to set database password"

    # Create a database for our new user
    sudo -u postgres createdb \
        --encoding=UTF-8 \
        --owner="$LAVA_DB_USER" \
        --template=template0 \
        --no-password \
        "$LAVA_DB_NAME" \
        || die "Failed to create a database"
}


defaults_broker() {
    export LAVA_RABBIT_VHOST="/lava-$LAVA_INSTANCE"
    export LAVA_RABBIT_USER="lava-$LAVA_INSTANCE"
    export LAVA_RABBIT_PASSWORD=$(dd if=/dev/urandom bs=1 count=128 2>/dev/null | md5sum | cut -d ' ' -f 1)
}


wizard_broker() {
    echo
    echo "RabbitMQ configuration"
    echo "^^^^^^^^^^^^^^^^^^^^^^"
    echo
    echo "We will use RabbitMQ to coordinate the distributed state"
    echo "of various LAVA components. For isolation each instance"
    echo "has a separate 'virtual host' created inside RabbitMQ'"
    echo "and runs as a separate RabbitMQ user (this is not a"
    echo "system user account) and password"
    echo
    echo "Broker vhost: $LAVA_RABBIT_VHOST"
    echo "Broker user:  $LAVA_RABBIT_USER"
    echo "   password:  $LAVA_RABBIT_PASSWORD (automatically generated)"
    echo
    echo "(this is just a notification, it is not configurable)"
    echo
    echo "next    - continue"

    _read_input "Please decide what to do [next]: " RESPONSE next

    case "$RESPONSE" in
        next)
            return 0  # loop complete
    esac
    return 1  # another loop please
}


install_broker() {
    set -x
    sudo rabbitmqctl add_user "$LAVA_RABBIT_USER" "$LAVA_RABBIT_PASSWORD"
    sudo rabbitmqctl add_vhost "$LAVA_RABBIT_VHOST"
    sudo rabbitmqctl set_permissions -p "$LAVA_RABBIT_VHOST" "$LAVA_RABBIT_USER" ".*" ".*" ".*"
    set +x
}


defaults_web_hosting() {
    export LAVA_APACHE_VHOST=$(hostname)
}

wizard_web_hosting() {
    echo
    echo "Apache and uWSGI configuration"
    echo "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
    echo
    echo "We will use Apache 2 to serve static application files"
    echo "Apache will also use mod uWSGI to talk to the application"
    echo "servers running LAVA code"
    echo
    echo "Normally we use django-seatbelt to prevent importing code"
    echo "from outside of each instance (for isolation and reliability)"
    echo "but this may be annoying when you do development and have"
    echo "some code in your \$HOME directory."
    echo
    echo "Developer mode: $LAVA_DEV_MODE"
    echo
    echo "next    - continue"
    echo "dev     - toggle developer mode"

    _read_input "Please decide what to do [next]: " RESPONSE next

    case "$RESPONSE" in
        next)
            return 0  # loop complete
            ;;
        dev)
            if [ $LAVA_DEV_MODE = yes ]; then
                LAVA_DEV_MODE=no
            else
                LAVA_DEV_MODE=yes
            fi
            return 1
            ;;
    esac
    return 1  # another loop please
}

generate_conf_d_file(){
    # Create apache2 instance configuration for single IP machine
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/etc/apache2/conf.d/ 
    cat >$LAVA_PREFIX/$LAVA_INSTANCE/etc/apache2/conf.d/${LAVA_INSTANCE}.conf <<INSTANCE_FOR_SINGLE_IP

# set the static files directory for this instance
Alias  /${LAVA_INSTANCE}-static/ $LAVA_PREFIX/$LAVA_INSTANCE/var/www/lava-server/static/

# Allow serving media, static and other custom files
<Directory $LAVA_PREFIX/$LAVA_INSTANCE/var/www>
    Options FollowSymLinks
    AllowOverride None
    Order allow,deny
    allow from all
</Directory>

# uWSGI mount point. For this to work the uWSGI module needs be loaded.
# XXX: Perhaps we should just load it ourselves here, dunno.
<Location /${LAVA_INSTANCE}>
    SetHandler              uwsgi-handler
    uWSGISocket             $LAVA_PREFIX/$LAVA_INSTANCE/run/uwsgi.sock
</Location>

INSTANCE_FOR_SINGLE_IP
}


install_web_hosting() {
    logger "Installing uWSGI and other hosting parts for LAVA instance $LAVA_INSTANCE"

    # Create apache2 site
    cat >$LAVA_PREFIX/$LAVA_INSTANCE/etc/apache2/sites-available/lava-server.conf <<INSTANCE_SITE
<VirtualHost *:80>
    ServerAdmin webmaster@localhost
    ServerName $LAVA_APACHE_VHOST

    # Allow serving media, static and other custom files
    <Directory $LAVA_PREFIX/$LAVA_INSTANCE/var/www>
        Options FollowSymLinks
        AllowOverride None
        Order allow,deny
        allow from all
    </Directory>

    # This is a small directory with just the index.html file that tells users
    # about this instance has a link to application pages
    DocumentRoot        $LAVA_PREFIX/$LAVA_INSTANCE/var/www/lava-server

    # uWSGI mount point. For this to work the uWSGI module needs be loaded.
    # XXX: Perhaps we should just load it ourselves here, dunno.
    <Location />
        SetHandler              uwsgi-handler
        uWSGISocket             $LAVA_PREFIX/$LAVA_INSTANCE/run/uwsgi.sock
    </Location>

    # Make exceptions for static and media.
    # This allows apache to serve those and offload the application server
    <Location /static>
        SetHandler      none
    </Location>
    # We don't need media files as those are private in our implementation
 
    # images folder for lava-dispatcher tarballs
    <Location /images>
        SetHandler      none
    </Location>


</VirtualHost>
INSTANCE_SITE

    sudo ln -s $LAVA_PREFIX/$LAVA_INSTANCE/etc/apache2/sites-available/lava-server.conf /etc/apache2/sites-available/$LAVA_INSTANCE.conf

    generate_conf_d_file

    # Create reload file
    echo "Touching this file will gracefully restart uWSGI worker for LAVA instance: $LAVA_INSTANCE" > $LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/uwsgi.reload

    # Create uWSGI configuration file
    cat >$LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/uwsgi.ini <<UWSGI_INI
[uwsgi]
home = $LAVA_PREFIX/$LAVA_INSTANCE/var/lib/bootstrap-venv
socket = $LAVA_PREFIX/$LAVA_INSTANCE/run/uwsgi.sock
chmod-socket = 660
wsgi-file = $LAVA_PREFIX/$LAVA_INSTANCE/bin/lava-server.wsgi
master = true
workers = 8
logto = $LAVA_PREFIX/$LAVA_INSTANCE/var/log/lava-uwsgi.log
log-master = true
auto-procname = true
touch-reload = $LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/uwsgi.reload
gid = $LAVA_SYS_USER
uid = $LAVA_SYS_USER
UWSGI_INI

    sudo a2ensite $LAVA_INSTANCE.conf
    sudo a2dissite 000-default || true
    sudo service apache2 restart
}


defaults_app() {
    true
}


wizard_app() {
    echo
    echo "LAVA application configuration"
    echo "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
    echo
    if [ "$LAVA_DEV_MODE" = yes ]; then
        LAVA_SERVER_DEBUG=true
    else
        LAVA_SERVER_DEBUG=false
    fi
    return 0
}


install_app() {
    echo "Installing/upgrading application code from a revision of $LAVA_MANIFEST_BRANCH"

    if [ ! -e $LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/settings.conf ]; then
        echo "Generating $LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/settings.conf for PRODUCTION"
        cat >$LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/settings.conf <<SETTINGS_CONF
{
    "DEBUG": $LAVA_SERVER_DEBUG,
    "TEMPLATE_DIRS": [
        "$LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/templates",
        "$LAVA_PREFIX/$LAVA_INSTANCE/code/current/server_code/templates/"
    ],
    "STATICFILES_DIRS": [
        ["lava-server", "$LAVA_PREFIX/$LAVA_INSTANCE/code/current/server_code/htdocs/"]
    ],
    "MEDIA_ROOT": "$LAVA_PREFIX/$LAVA_INSTANCE/var/lib/lava-server/media",
    "STATIC_ROOT": "$LAVA_PREFIX/$LAVA_INSTANCE/var/www/lava-server/static",
    "MEDIA_URL": "/media/",
    "STATIC_URL": "/static/",
    "MOUNT_POINT": "/",
    "LOGIN_URL": "/accounts/login/",
    "LOGIN_REDIRECT_URL": "/",
    "BROKER_USER": "$LAVA_RABBIT_USER",
    "BROKER_VHOST": "$LAVA_RABBIT_VHOST",
    "BROKER_PASSWORD": "$LAVA_RABBIT_PASSWORD",
    "DATAREPORT_DIRS": [
        "$LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/reports"
    ],
    "DATAVIEW_DIRS": [
        "$LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/views"
    ]
}
SETTINGS_CONF
    fi

    local venv="$LAVA_PREFIX/$LAVA_INSTANCE/var/lib/bootstrap-venv"
    local code="$LAVA_PREFIX/$LAVA_INSTANCE/code/r$LAVA_REVNO"

    set -ex
    if [ ! -e ${code} ]; then
        bzr branch -r $LAVA_REVNO $LAVA_MANIFEST_BRANCH $code
        mkdir ${code}/bin
        [ -d $LAVA_PREFIX/$LAVA_INSTANCE/code/current/local ] && \
            find $LAVA_PREFIX/$LAVA_INSTANCE/code/current/local \
            -maxdepth 1 -type l -exec cp -P \{} $code/local/ \;
        ln -s ${venv}/bin/{uwsgi,buildout} ${code}/bin/
        ln -s $LAVA_DOWNLOAD_CACHE ${code}/download-cache
        ln -s $LAVA_EGG_CACHE ${code}/eggs
    fi
    # If LAVA_BUILDOUT_CFG does not specify a file in the branch,
    # symlink it in here before running buildout (as buildout works
    # relative to the config file).
    local cfg="$(basename "${LAVA_BUILDOUT_CFG}")"
    if [ "${cfg}" != "${LAVA_BUILDOUT_CFG}" ]; then
        ln -sfT "${LAVA_BUILDOUT_CFG}" "${code}/${cfg}"
    fi
    pushd $code
    ${venv}/bin/buildout -c "${cfg}"
    popd
    set +ex

    gen_lava_dispatcher_config

    ln -sfT $code $LAVA_PREFIX/$LAVA_INSTANCE/code/current
}


defaults_config_app() {
    export LAVA_SCHEDULER_ENABLED=yes
}


wizard_config_app() {
    _read_input "Enable the scheduler in this instance (yes/no)? [yes] " LAVA_SCHEDULER_ENABLED yes

    _read_input "Do you want to configure the lava-dispatcher (yes/no)? [yes] " LAVA_DISPATCHER_CONFIG yes

    if [ $LAVA_DISPATCHER_CONFIG = yes ]; then
        config_lava_dispatcher
    fi

    return 0
}

config_lava_dispatcher() {
    echo "Lava Dispatcher Configuration"
    echo "-----------------------------"

    echo "LAVA_SERVER_IP"
    echo "^^^^^^^^^^^^^^"
    echo "This is the IP the device downloads the image parts from"
    echo ""
    echo "Here is the list of network device on this host"

    ip addr | grep 'inet [0-9]' | grep -v 'scope host'

    if [ -z "$LAVA_SERVER_IP" ]; then
        # try the IP associated with the default gateway
        local iface=$(ip route | awk '{ if ($1 == "default") { print($5) } }')
        LAVA_SERVER_IP=$(ip addr show "$iface" | awk '{ if ($1 == "inet") { gsub("/.*", "", $2); print($2) } }')
    fi

    while true; do

        _read_input "Please enter the IP address: " LAVA_SERVER_IP

        if test -n "$LAVA_SERVER_IP" && echo "$LAVA_SERVER_IP" | grep -q -E -e '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'; then
            echo "The IP address is '$LAVA_SERVER_IP'"
            break
        else
            echo "$LAVA_SERVER_IP is not a valid IP address."
            if [ "$LAVA_NON_INTERACTIVE" = "yes" ]; then
                exit 1
            fi
        fi
    done

    echo
    echo "LAVA_PROXY"
    echo "^^^^^^^^^^"

    echo "This is the address and port of cache proxy service, format is like:"
    echo "http://192.168.1.10:3128/"
    _read_input "Please enter the URL: " LAVA_PROXY


    # Location for rootfs/boot tarballs extracted from images
    export LAVA_IMAGE_TMPDIR=$LAVA_PREFIX/$LAVA_INSTANCE/var/www/lava-server/images

    # URL where LAVA_IMAGE_TMPDIR can be accessed remotely
    export LAVA_IMAGE_URL=http://$SERVER_IP/lava-server/images

    # Location on the device for storing test results.
    export LAVA_RESULT_DIR=$LAVA_PREFIX/$LAVA_INSTANCE/tmp

    # Location for caching downloaded artifacts such as hwpacks and images
    export LAVA_CACHEDIR=$LAVA_PREFIX/$LAVA_INSTANCE/var/cache/lava-dispatcher

}

gen_lava_dispatcher_config() {
    LAVA_DISPATCHER_CONFIG_FILE=$LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-dispatcher/lava-dispatcher.conf

    if [ -e "${LAVA_DISPATCHER_CONFIG_FILE}" ]; then
        echo "Not overwriting lava-dispatcher config file $LAVA_DISPATCHER_CONFIG_FILE"
        return
    fi

    echo "Creating lava-dispatcher config file $LAVA_DISPATCHER_CONFIG_FILE"
    sudo sh -c "cat >$LAVA_DISPATCHER_CONFIG_FILE" <<LAVA_DISPATCHER_CONF
# This file was automatically generated by lava-deployment-tool.sh

LAVA_SERVER_IP = $LAVA_SERVER_IP

# Location for rootfs/boot tarballs extracted from images
LAVA_IMAGE_TMPDIR = $LAVA_IMAGE_TMPDIR

# URL where LAVA_IMAGE_TMPDIR can be accessed remotely
LAVA_IMAGE_URL = http://%(LAVA_SERVER_IP)s/images

# Location on the device for storing test results.
LAVA_RESULT_DIR = $LAVA_RESULT_DIR

# Location for caching downloaded artifacts such as hwpacks and images
LAVA_CACHEDIR = $LAVA_CACHEDIR

# This is the address and port of cache proxy service, format is like:
# LAVA_PROXY = http://192.168.1.10:3128/
LAVA_PROXY = $LAVA_PROXY

# The url point to the version of lava-test to be install with pip
#LAVA_TEST_URL = bzr+http://bazaar.launchpad.net/~le-chi-thu/lava-test/enabled-file-cache/#egg=lava-test

# Python logging level to use
# # 10 = DEBUG
# # 20 = INFO
# # 30 = WARNING
# # 40 = ERROR
# # Messages with a lower number than LOGGING_LEVEL will be suppressed
# LOGGING_LEVEL = 10

LAVA_DISPATCHER_CONF

}

install_config_app() {
    # Enable virtualenv
    . $LAVA_PREFIX/$LAVA_INSTANCE/bin/activate

    if [ "${LAVA_SCHEDULER_ENABLED-x}" = "x" ]; then
        # LAVA_SCHEDULER_ENABLED was not in the config.
        # Set it to 'yes' as that was the assumed behaviour before
        # LAVA_SCHEDULER_ENABLED was introduced.
        echo "Setting LAVA_SCHEDULER_ENABLED to 'yes'..."
        export LAVA_SCHEDULER_ENABLED='yes'
        _save_config
    fi

    echo "Building cache of static files..."
    set -x
    rm -rf $LAVA_PREFIX/$LAVA_INSTANCE/var/www/lava-server/static
    lava-server manage \
        build_static --noinput --link || die "Failed to update the cache of static content"
    set +x

    echo "Stopping instance for database changes..."
    set -x
    sudo stop lava-instance LAVA_INSTANCE=$LAVA_INSTANCE || true # in case of upgrades
    set +x

    echo "Synchronizing database..."
    set -x
    lava-server manage \
        syncdb --noinput || die "Failed to synchronize database (run non-migration db updates)"
    set +x

    echo "Running migrations..."
    set -x
    lava-server manage \
        migrate --noinput || die "Failed to run database migrations"
    set +x

    # Get out of virtualenv
    deactivate

    echo "Starting instance again..."
    set -x
    sudo start lava-instance LAVA_INSTANCE=$LAVA_INSTANCE
    set +x
}


check_min_version() {
    SETUP_VER=0
    if [ -e $LAVA_PREFIX/.setup ]; then
        SETUP_VER=$(cat $LAVA_PREFIX/.setup)
    fi

    if [ $SETUP_VER -lt $LAVA_SETUP_REQUIRED_VERSION ]; then
        die "Please run '$0 setup' first"
    fi
}

ensure_downloaded_check_sha256 () {
    local url="$1"
    local sha256="$2"
    local filename="$(basename "$url")"
    if [ ! -f "$filename" ]; then
        wget "$url"
    fi
    echo "$sha256  $filename" | sha256sum -c || die "checksum mismatch on $filename"
}

cmd_setup() {
    SETUP_VER=0
    if [ -e $LAVA_PREFIX/.setup ]; then
        SETUP_VER=$(cat $LAVA_PREFIX/.setup)
    fi


    if [ $SETUP_VER -lt $LAVA_SETUP_REQUIRED_VERSION ]; then
        echo "===================="
        echo "LAVA Deployment Tool"
        echo "===================="
        echo
        echo "System preparation steps:"
        echo " 1) Installing $LAVA_PKG_LIST"
        echo " 2) Setting up $LAVA_PREFIX owned by you"
        echo " 3) Setting up the egg and download cache for buildbot"
        echo " 4) Setting up upstart jobs (incuding removal of stale jobs)"
        echo
        _read_input "Type YES to continue, anything else to abort: " RESPONSE YES
        test "$RESPONSE" = 'YES' || return

        set -xe

        echo "Add Linaro tools ppa"
        sudo apt-get install --yes python-software-properties
        sudo add-apt-repository --yes ppa:linaro-maintainers/tools
        sudo apt-get update

        echo "Installing english language pack, if needed"
        # XXX: I'm not 100% sure this is needed
        sudo apt-get install --yes language-pack-en

        # Use English locale, this is VERY important for PostgreSQL locale settings
        # XXX: I don't like en_US.UTF-8, is there any POSIX.UTF-8 we could use?
        echo "Installing essential packages, if needed"
        LANG=en_US.UTF-8 sudo apt-get install --yes $LAVA_PKG_LIST

        echo "Creating LAVA filesystem in $LAVA_PREFIX"
        sudo mkdir -p $LAVA_PREFIX
        echo "Making $(whoami) the owner of that location"
        sudo chown $(whoami):$(id -gn) $LAVA_PREFIX

        echo "Creating buildout caches"
        sudo mkdir -p $LAVA_EGG_CACHE
        sudo chown $(whoami):$(id -gn) $LAVA_EGG_CACHE
        sudo mkdir -p $LAVA_DOWNLOAD_CACHE/dist
        sudo chown -R $(whoami):$(id -gn) $LAVA_DOWNLOAD_CACHE
        pushd $LAVA_DOWNLOAD_CACHE/dist
        ensure_downloaded_check_sha256 \
            http://pypi.python.org/packages/source/d/distribute/distribute-0.6.24.tar.gz \
            c61fde9f388c9600eb8ee54bd7168039c5fb74fa334138bc49cdf6a6c1341627
        ensure_downloaded_check_sha256 \
            https://launchpad.net/bzr/2.5/2.5.1/+download/bzr-2.5.1.tar.gz \
            967346fa6cc52971a8dfd5171ec22e1928cf455fb4317013b05b0915ff927982
        ensure_downloaded_check_sha256 \
            http://projects.unbit.it/downloads/old/uwsgi-$LAVA_UWSGI.tar.gz \
            81dc137bc8b7b3962e527cafb1a719342c34eb07d568dc61c7766f9a9bcdee62
        ensure_downloaded_check_sha256 \
            http://pypi.python.org/packages/source/z/zc.buildout/zc.buildout-1.5.2.tar.gz \
            0ac5a325d3ffbc5a988fb3ba87f4159d4769cc73e3331cb5234edc8839b6506b
        popd

        set +x
        echo "Creating upstart script for: lava"
        sudo sh -c "cat >/etc/init/lava.conf" <<LAVA_CONF
author "Zygmunt Krynicki"
description "LAVA (abstract task)"

start on runlevel [2345]
stop on runlevel [06]

post-start script
    logger "Started LAVA (all instances)"
end script

post-stop script
    logger "Stopped LAVA (all instances)"
end script
LAVA_CONF

        echo "Creating upstart script for: lava-instances"
        sudo sh -c "cat >/etc/init/lava-instances.conf" <<LAVA_CONF
author "Zygmunt Krynicki"
description "LAVA (instances)"

start on starting lava

task

script
    for dir in \`ls /srv/lava/instances\`; do
        LAVA_INSTANCE=\`basename \$dir\`
# TODO: Check if the instance should start automatically on boot
        if [ -e $LAVA_PREFIX/\$LAVA_INSTANCE/instance.conf ]; then
            start lava-instance LAVA_INSTANCE=\$LAVA_INSTANCE
        fi
    done
end script
LAVA_CONF

        sudo rm -f "/etc/init/lava-uwsgi-workers.conf"

        echo "Creating upstart script for: lava-instance"
        sudo sh -c "cat >/etc/init/lava-instance.conf" <<LAVA_CONF
author "Zygmunt Krynicki"
description "LAVA (instance)"

# Stop when lava is being stopped
stop on stopping lava

# Use LAVA_INSTANCE to differentiate instances
instance \$LAVA_INSTANCE

# Export the instance name so that we can use it in other
# related LAVA jobs.
export LAVA_INSTANCE

pre-start script
    # Don't start unless the instance configuration file is present
    if [ ! -e $LAVA_PREFIX/\$LAVA_INSTANCE/instance.conf ]; then
        stop
    else
        logger "LAVA instance (\$LAVA_INSTANCE) starting..."
    fi
end script

post-start script
    logger "LAVA instance (\$LAVA_INSTANCE) started"
end script

pre-stop script
    logger "LAVA instance (\$LAVA_INSTANCE) stopping..."
end script

post-stop script
    logger "LAVA instance (\$LAVA_INSTANCE) stopped"
end script
LAVA_CONF

        sudo rm -f /etc/init/lava-uwsgi-instance.conf

        echo "Creating upstart script for: lava-instance-uwsgi"
        sudo sh -c "cat >/etc/init/lava-instance-uwsgi.conf" <<LAVA_CONF
author "Zygmunt Krynicki"
description "LAVA uWSGI worker"

# This is an instance job, there are many possible workers
# each with different instance variable.
instance \$LAVA_INSTANCE

# Stop and start along with the rest of the instance
start on starting lava-instance
stop on stopping lava-instance LAVA_INSTANCE=\$LAVA_INSTANCE
# TODO: make uwsgi compatible with upstart socket activation
# start on socket PROTO=unix PATH=$LAVA_PREFIX/\$LAVA_INSTANCE/run/uwsgi.sock

# We want each worker to respawn if it gets hurt.
respawn

# Announce activity
pre-start script
    # Don't start unless the instance configuration file is present
    if [ ! -e $LAVA_PREFIX/\$LAVA_INSTANCE/instance.conf ]; then
        stop
    else
        # Announce uWSGI becoming online
        logger "LAVA instance (\$LAVA_INSTANCE) uWSGI starting..."
    fi
end script

post-start script
    logger "LAVA instance (\$LAVA_INSTANCE) uWSGI started"
end script

pre-stop script
    logger "LAVA instance (\$LAVA_INSTANCE) uWSGI stopping..."
end script

post-stop script
    logger "LAVA instance (\$LAVA_INSTANCE) uWSGI stopped"
end script

# uWSGI wants to be killed with SIGQUIT to indicate shutdown
# NOTE: this is not supported on Lucid (upstart is too old)
# Currently no workaround exists
kill signal SIGQUIT

# Run uWSGI with instance specific configuration file
script
    # Load instance settings
    . $LAVA_PREFIX/\$LAVA_INSTANCE/instance.conf
    # Simluate virtualenv without spawing anything
    export VIRTUAL_ENV=$LAVA_PREFIX/\$LAVA_INSTANCE
    export PATH=\$VIRTUAL_ENV/bin:\$PATH
    # Start uwsgi, no forks, no daemons, gid/uid changing is managed by uwsgi
    exec $LAVA_PREFIX/\$LAVA_INSTANCE/bin/uwsgi --ini=$LAVA_PREFIX/\$LAVA_INSTANCE/etc/lava-server/uwsgi.ini
end script
LAVA_CONF

        echo "Removing stale upstart file (if needed): lava-celeryd-instance"
        sudo rm -f /etc/init/lava-celeryd-instance.conf

        echo "Creating upstart script for: lava-instance-celeryd"
        sudo sh -c "cat >/etc/init/lava-instance-celeryd.conf" <<LAVA_CONF
author "Zygmunt Krynicki"
description "LAVA Celery worker"

# This is an instance job, there are many possible workers
# each with different instance variable.
instance \$LAVA_INSTANCE

# Stop and start along with the rest of the instance
# start on starting lava-instance
# stop on stopping lava-instance LAVA_INSTANCE=\$LAVA_INSTANCE
# FIXME: upstart + virtualenv + pid tracking + sudo is broken, needs attention, celery is not part of this release

# Respawn the worker if it got hurt
respawn

# Announce workers becoming online
pre-start script
    # Don't start unless the instance configuration file is present
    if [ ! -e $LAVA_PREFIX/\$LAVA_INSTANCE/instance.conf ]; then
        stop
    else
        # Announce uWSGI becoming online
        logger "LAVA instance (\$LAVA_INSTANCE) celery worker starting..."
    fi
end script

post-start script
    logger "LAVA instance (\$LAVA_INSTANCE) celery worker started"
end script

pre-stop script
    logger "LAVA instance (\$LAVA_INSTANCE) celery worker stopping..."
end script

post-stop script
    logger "LAVA instance (\$LAVA_INSTANCE) celery worker stopped"
end script

# Some workers can take a while to exit, this should be enough
kill timeout 360

kill signal SIGTERM

# Run celery daemon 
script
    . $LAVA_PREFIX/\$LAVA_INSTANCE/bin/activate
    . $LAVA_PREFIX/\$LAVA_INSTANCE/instance.conf
    exec $LAVA_PREFIX/\$LAVA_INSTANCE/bin/lava celeryd >$LAVA_PREFIX/\$LAVA_INSTANCE/var/log/lava-celeryd.log 2>&1

end script

LAVA_CONF

        echo "Creating upstart script for: lava-instance-scheduler"
        sudo sh -c "cat >/etc/init/lava-instance-scheduler.conf" <<LAVA_CONF
author "Zygmunt Krynicki"
description "LAVA Scheduler"

# This is an instance job, there are many possible workers
# each with different instance variable.
instance \$LAVA_INSTANCE

# Stop and start along with the rest of the instance
start on starting lava-instance
stop on stopping lava-instance LAVA_INSTANCE=\$LAVA_INSTANCE

# Respawn the worker if it got hurt
respawn

# Announce workers becoming online
pre-start script
    # Don't start unless the instance configuration file is present
    if [ ! -e $LAVA_PREFIX/\$LAVA_INSTANCE/instance.conf ]; then
        stop
    else
        . $LAVA_PREFIX/\$LAVA_INSTANCE/instance.conf
        # We only prevent the scheduler from running if
        # LAVA_SCHEDULER_ENABLED is set and set to 'no', to be most
        # compatible with the previous behaviour of always running the
        # scheduler.
        if [ "x\$LAVA_SCHEDULER_ENABLED" = "xno" ]; then
            stop
        else
            logger "LAVA instance (\$LAVA_INSTANCE) scheduler starting..."
        fi
    fi
end script

post-start script
    logger "LAVA instance (\$LAVA_INSTANCE) scheduler started"
end script

pre-stop script
    logger "LAVA instance (\$LAVA_INSTANCE) scheduler stopping..."
end script

post-stop script
    logger "LAVA instance (\$LAVA_INSTANCE) scheduler stopped"
end script

script
    # Load instance settings
    . $LAVA_PREFIX/\$LAVA_INSTANCE/instance.conf
    # Simluate virtualenv without spawing anything
    export VIRTUAL_ENV=$LAVA_PREFIX/\$LAVA_INSTANCE
    export PATH=\$VIRTUAL_ENV/bin:\$PATH
    # Start LAVA scheduler, it runs as root in this release
    exec $LAVA_PREFIX/\$LAVA_INSTANCE/bin/lava-server manage --instance-template=$LAVA_PREFIX/{instance}/etc/lava-server/{{filename}}.conf --instance=\$LAVA_INSTANCE scheduler --logfile=$LAVA_PREFIX/\$LAVA_INSTANCE/var/log/lava-scheduler.log --loglevel=info
end script
LAVA_CONF

        if [ \! -e /etc/apache2/mods-available/uwsgi.load ]; then
            echo "Building uWSGI apache module..."
            _tmpdir="$(mktemp -d)"

            trap "rm -rf \"${_tmpdir}\"" EXIT
            set -x
            pushd $_tmpdir
            tar -xzf $LAVA_DOWNLOAD_CACHE/dist/uwsgi-$LAVA_UWSGI.tar.gz --strip-components=1
            cd apache2
            apxs2 -c mod_uwsgi.c
            sudo apxs2 -i -a mod_uwsgi.la
            popd
            set +x
        fi

        # Store setup version
        echo $LAVA_SETUP_REQUIRED_VERSION > $LAVA_PREFIX/.setup
        echo "Setup complete, you can now install LAVA"
    else
        echo "This step has been already performed"
    fi
}


die() {
    echo "$1"
    exit 1
}


_banner() {
    echo "===================="
    echo "LAVA Deployment Tool"
    echo "===================="
    echo
}


cmd_install() {
    export LAVA_INSTANCE=$1
    export LAVA_REVNO=$2

    check_min_version
    _banner

    if [ -z "$LAVA_INSTANCE" ]; then
        echo "You need to pass the name of the instance to create as first argument"
        return
    fi

    if [ -z "$LAVA_REVNO" ]; then
        echo -n "Determining revno to deploy... "
        LAVA_REVNO="$(bzr revno $LAVA_MANIFEST_BRANCH)"
        echo $LAVA_REVNO
    fi

    # Sanity checking, ensure that instance does not exist yet
    if [ -d "$LAVA_PREFIX/$LAVA_INSTANCE" ]; then
        echo "Instance $LAVA_INSTANCE already exists"
        return
    fi

    # Configure everything first (get all the answers)
    _configure "$LAVA_INSTANCE"
    # Roll the installation
    _install
}


cmd_upgrade() {
    export LAVA_INSTANCE=$1
    export LAVA_REVNO=$2

    check_min_version
    _banner

    if [ -z "$LAVA_INSTANCE" ]; then
        echo "You need to pass the name of the instance to create as first argument"
        return
    fi

    _load_configuration "$LAVA_INSTANCE"

    if [ -z "$LAVA_REVNO" ]; then
        echo -n "Determining revno to deploy... "
        LAVA_REVNO="$(bzr revno $LAVA_MANIFEST_BRANCH)"
        echo $LAVA_REVNO
    fi

    # Sanity checking, ensure that instance exist
    if [ \! -d "$LAVA_PREFIX/$LAVA_INSTANCE" ]; then
        echo "Instance $LAVA_INSTANCE does not exist"
        return
    fi

    _maybe_pre_convert_to_buildout
    install_app
    _maybe_post_convert_to_buildout
    install_config_app
}


_maybe_pre_convert_to_buildout () {
    if [ -e $LAVA_PREFIX/$LAVA_INSTANCE/code ]; then
        return
    fi
    if [ ! -e $LAVA_PREFIX/$LAVA_INSTANCE/lib ]; then
        echo "Instance appears to be neither pip based or buildout based."
        echo "Cowardly refusing to proceed."
        exit 1;
    fi

    echo "$LAVA_INSTANCE appears to be a pip based instance"
    echo "This script can attempt to convert it, but this may "
    echo "lose any custom packages you have installed unless you "
    echo "already have a plan to cope with that."
    echo
    _read_input "Proceed? (y/n) " RESPONSE

    if [ "$RESPONSE" != 'y' ]; then
        exit 1;
    fi

    set -xe
    _save_config
    install_buildout
    bzr init-repo $LAVA_PREFIX/$LAVA_INSTANCE/code
    set +xe
}


_maybe_post_convert_to_buildout () {
    local instpath=$LAVA_PREFIX/$LAVA_INSTANCE
    set -xe
    if [ ! -e $instpath/lib ]; then
        return
    fi
    $instpath/bin/pip freeze > $instpath/last-pip-installed-versions.txt
    rm -rf $instpath/{bin,lib,src,build,local}
    rm $instpath/etc/lava-server/lava-server.wsgi
    ln -s $instpath/code/current/bin $instpath
    sed -i -e 's%lib/python2\../site-packages/lava_server%code/current/server_code%' \
        $instpath/etc/lava-server/settings.conf
    sed -i -e "s%home = $instpath%&/var/lib/bootstrap-venv%" \
        -e "s%$instpath/etc/lava-server/lava-server\.wsgi%$instpath/bin/lava-server.wsgi%" \
        $instpath/etc/lava-server/uwsgi.ini
    set +xe
}


cmd_remove() {
    LAVA_INSTANCE=${1:-dev}

    _banner

    # Sanity checking, ensure that instance exists
    if [ \! -d "$LAVA_PREFIX/$LAVA_INSTANCE" ]; then
        echo "Instance $LAVA_INSTANCE does not exist"
        return
    fi

    _load_configuration "$LAVA_INSTANCE"

    echo "*** WARNING ***" 
    echo "You are about to IRREVERSIBLY DESTROY the instance $LAVA_INSTANCE"
    echo "There is no automatic backup, there is no way to undo this step"
    echo "*** WARNING ***" 

    echo "We will remove system user $LAVA_SYS_USER"
    echo "We will remove PostgreSQL database $LAVA_DB_NAME"
    echo "We will remove PostgreSQL user: $LAVA_DB_USER"
    echo "We will remove everything in $LAVA_PREFIX/$LAVA_INSTANCE"
    echo "We will remove the apache site $LAVA_INSTANCE.conf"
    echo "We will remove the RabbitMQ user: $LAVA_RABBIT_USER"
    echo "We will remove the RabbitMQ vhost: $LAVA_RABBIT_VHOST"
    echo
    _read_input "Type DESTROY to continue: " RESPONSE
    test "$RESPONSE" = 'DESTROY' || return

    logger "Removing LAVA instance $LAVA_INSTANCE"

    set -e
    set -x
    # Remove everything 
    sudo stop lava-instance LAVA_INSTANCE=$LAVA_INSTANCE || true
    sudo rm -f "/etc/apache2/sites-available/$LAVA_INSTANCE.conf" || true
    sudo rm -f "/etc/apache2/sites-enabled/$LAVA_INSTANCE.conf" || true
    sudo rm -f "/etc/apache2/conf.d/$LAVA_INSTANCE.conf" || true
    sudo -u postgres dropdb "$LAVA_DB_NAME" || true
    sudo -u postgres dropuser "$LAVA_DB_USER" || true
    sudo rabbitmqctl delete_user "$LAVA_RABBIT_USER" || true
    sudo rabbitmqctl delete_vhost "$LAVA_RABBIT_VHOST" || true
    sudo userdel "$LAVA_SYS_USER" || true
    sudo rm -rf "$LAVA_PREFIX/$LAVA_INSTANCE" || true
    set +x
    set +e
}


_find_snapshot () {
    LAVA_INSTANCE=${1}

    check_min_version
    set -e

    # Sanity checking, ensure that instance exists
    if [ \! -d "$LAVA_PREFIX/$LAVA_INSTANCE" ]; then
        echo "Instance $LAVA_INSTANCE does not exist"
        return
    fi

    local SNAPSHOT_ID=${2}
    local SNAPSHOT_PATH="$LAVA_ROOT/backups/$LAVA_INSTANCE/$SNAPSHOT_ID"
    local SNAPSHOT_PATH_ALT="$LAVA_ROOT/backups/$SNAPSHOT_ID"

    if [ -e "$SNAPSHOT_PATH" ]; then
        echo "$SNAPSHOT_PATH"
    else
        if [ -e "$SNAPSHOT_PATH_ALT" ]; then
            echo "$SNAPSHOT_PATH_ALT"
        else
            echo "Cannot find snapshot called '$SNAPSHOT_ID'"
            echo "It should be in $SNAPSHOT_PATH or $SNAPSHOT_PATH_ALT (alternative)"
            exit 1
        fi
    fi
}

_restore_db_from_dump () {

    # Load database configuration
    . $LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/default_database.conf

    # Substitute missing defaults for IP-based connection this works around a bug
    # in postgresql configuration on default Ubuntu installs and allows us to use
    # the ~/.pgpass file.
    test -z "$dbport" && dbport=5432
    test -z "$dbserver" && dbserver=localhost

    if [ "$dbserver" != "localhost" ]; then
        echo "You can only run restore on the host on which postgres is running"
        return
    fi

    set -x

    sudo -u postgres dropdb \
        --port $dbport \
        $dbname || true
    sudo -u postgres createdb \
        --encoding=UTF-8 \
        --owner=$dbuser \
        --port $dbport \
        --no-password \
        $dbname
    sudo -u postgres pg_restore \
        --exit-on-error --no-owner \
        --port $dbport \
        --role $dbuser \
        --dbname $dbname \
        "${1}" > /dev/null
}

cmd_restore-db () {
    set -e
    LAVA_INSTANCE=${1}
    local SNAPSHOT_ID=${2}
    SNAPSHOT="$(_find_snapshot $LAVA_INSTANCE $SNAPSHOT_ID)"

    _load_configuration "$LAVA_INSTANCE"

    db_snapshot="$SNAPSHOT/database.dump"

    if [ \! -f "$db_snapshot" ]; then
        echo "$SNAPSHOT does not contain a db snapshot"
        exit 1
    fi

    if [ status lava-instance LAVA_INSTANCE=$LAVA_INSTANCE > /dev/null 2>&1 ]; then
        echo "LAVA instance $LAVA_INSTANCE appears to be running"
        exit 1
    fi

    echo "Are you sure you want to restore the database of $LAVA_INSTANCE from"
    echo "$SNAPSHOT_ID?  This will DESTROY the existing database of $LAVA_INSTANCE"
    echo
    _read_input "Type RESTORE to continue: " RESPONSE
    test "$RESPONSE" = 'RESTORE' || return

    _restore_db_from_dump "$db_snapshot"

    echo "Done"

}

cmd_restore() {
    set -e
    LAVA_INSTANCE=${1}
    local SNAPSHOT_ID=${2}
    SNAPSHOT="$(_find_snapshot $LAVA_INSTANCE $SNAPSHOT_ID)"

    _load_configuration "$LAVA_INSTANCE"

    db_snapshot="$SNAPSHOT/database.dump"
    files_snapshot="$SNAPSHOT/files.tar.gz"

    if [ \! -f "$db_snapshot" -o \! -f "$files_snapshot" ]; then
        echo "$SNAPSHOT does not look like a complete snapshot"
        return
    fi

    echo "Are you sure you want to restore instance $LAVA_INSTANCE from"
    echo "$SNAPSHOT_ID?  This will DESTROY the existing state of $LAVA_INSTANCE"
    echo
    _read_input "Type RESTORE to continue: " RESPONSE
    test "$RESPONSE" = 'RESTORE' || return

    _restore_db_from_dump "$db_snapshot"

    sudo rm -rf $LAVA_PREFIX/$LAVA_INSTANCE/var/lib/lava-server/
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/var/lib/lava-server/
    tar \
        --extract \
        --gzip \
        --directory $LAVA_PREFIX/$LAVA_INSTANCE/var/lib/lava-server/ \
        --file "$files_snapshot"

    # Allow instance to write to media directory
    sudo chgrp -R $LAVA_SYS_USER $LAVA_PREFIX/$LAVA_INSTANCE/var/lib/lava-server/
    sudo chmod -R g+rwXs $LAVA_PREFIX/$LAVA_INSTANCE/var/lib/lava-server/

    echo "Done"
}


cmd_backup() {
    LAVA_INSTANCE=${1:-dev}

    check_min_version
    set -e

    # Sanity checking, ensure that instance exists
    if [ \! -d "$LAVA_PREFIX/$LAVA_INSTANCE" ]; then
        echo "Instance $LAVA_INSTANCE does not exist"
        return
    fi

    # Load database configuration
    . $LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/default_database.conf

    # Substitute missing defaults for IP-based connection this works around a bug
    # in postgresql configuration on default Ubuntu installs and allows us to use
    # the ~/.pgpass file.
    test -z "$dbserver" && dbserver=localhost
    test -z "$dbport" && dbport=5432

    export PGPASSWORD=$dbpass

    snapshot_id=$(TZ=UTC date +%Y-%m-%dT%H-%M-%SZ)

    echo "Making backup with id: $snapshot_id"

    destdir="$LAVA_ROOT/backups/$LAVA_INSTANCE/$snapshot_id"

    mkdir -p "$destdir"

    set -x

    echo "Creating database snapshot..."

    pg_dump \
        --no-owner \
        --format=custom \
        --host=$dbserver \
        --port=$dbport \
        --username=$dbuser \
        --no-password $dbname \
        --schema=public \
        > "$destdir/database.dump"

    echo "Backing up instance configuration..."
    tar --create \
        --gzip \
        --directory $LAVA_PREFIX/$LAVA_INSTANCE/ \
        --file "$destdir/etc.tar.gz" \
        etc

    echo "Creating file repository snapshot..."
    # tar exiting with code 1 means that the files changed under us as
    # tar was running.  As this is to be expected, we suppress that
    # exit code.  Exit code 2 means something bad happened, and we
    # should stop.
    GZIP='--rsyncable' tar \
        --create \
        --ignore-failed-read \
        --warning=no-file-changed \
        --gzip \
        --directory $LAVA_PREFIX/$LAVA_INSTANCE/var/lib/lava-server/ \
        --file "$destdir/files.tar.gz" \
        . || [ $? == 1 ]
    #   ^ There is a DOT HERE don't remove it

    ln -sfT "$destdir" "$LAVA_ROOT/backups/$LAVA_INSTANCE/latest"

    echo "Done"
}


cmd_manage() {
    LAVA_INSTANCE=${1:-dev}
    test -n '$1' && shift

    # Sanity checking, ensure that instance exists
    if [ \! -d "$LAVA_PREFIX/$LAVA_INSTANCE" ]; then
        echo "Instance $LAVA_INSTANCE does not exist"
        return
    fi
    _load_configuration "$LAVA_INSTANCE"

    # Enable virtualenv
    . $LAVA_PREFIX/$LAVA_INSTANCE/bin/activate

    set -x
    lava-server manage \
        "$@"
    set +x
}


is_vhost(){
    export LAVA_INSTANCE=$1
    vhost_conf="/etc/apache2/sites-enabled/$LAVA_INSTANCE.conf"
    singleip_conf="/etc/apache2/conf.d/${LAVA_INSTANCE}.conf"
    if [ -f ${vhost_conf} ]; then
        echo 'vhost'
    elif [ -f ${singleip_conf} ]; then
        echo 'location'
    else
        echo 'unknown'
    fi
}


cmd_list(){

    _banner

    INSTANCES=`ls $LAVA_PREFIX`
    if [ "X${INSTANCES}" = "X" ]; then
        echo "NO INSTANCES"
        return
    else
        echo "================================"
        echo "INSTANCE_NAME     VHOST/LOCATION"
        echo "================================"
    fi
    for instance in ${INSTANCES}; do
        is_vhost_value=`is_vhost ${instance}`
        printf "%s\t%s\n" ${instance} ${is_vhost_value}
    done
    echo "================================"
}


toggle_instance() {
    export LAVA_INSTANCE=$1
    export TARGET=${2:vhost}

    if [ -z "$LAVA_INSTANCE" ]; then
        echo "You need to pass the name of the instance to create as first argument"
        return
    fi

    # Sanity checking, ensure that instance exist
    if [ \! -d "$LAVA_PREFIX/$LAVA_INSTANCE" ]; then
        echo "Instance $LAVA_INSTANCE does not exist"
        return
    fi

    settings_file="$LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/settings.conf"
    single_conf="$LAVA_PREFIX/$LAVA_INSTANCE/etc/apache2/conf.d/${LAVA_INSTANCE}.conf"
    reload_file="$LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/uwsgi.reload"

    if [ "x${TARGET}" = "xvhost" ]; then
        sudo rm /etc/apache2/conf.d/${LAVA_INSTANCE}.conf
        sed -i "s/    \"MEDIA_URL\": \"\/${LAVA_INSTANCE}-media\/\",/    \"MEDIA_URL\": \"\/media\/\",/" ${settings_file} 
        sed -i "s/    \"STATIC_URL\": \"\/${LAVA_INSTANCE}-static\/\",/    \"STATIC_URL\": \"\/static\/\",/" ${settings_file}
        sed -i "s/    \"LOGIN_URL\": \"\/${LAVA_INSTANCE}\/accounts\/login\/\",/    \"LOGIN_URL\": \"\/accounts\/login\/\",/" ${settings_file}
        sed -i "s/    \"LOGIN_REDIRECT_URL\": \"\/${LAVA_INSTANCE}\",/    \"LOGIN_REDIRECT_URL\": \"\/\",/" ${settings_file}
        touch ${reload_file}
        sudo a2ensite $LAVA_INSTANCE.conf
        if [ -e /etc/apache2/sites-enabled/000-default ]; then
            sudo a2dissite 000-default || true
        fi
        return 0
    elif [ "x${TARGET}" = "xlocation" ]; then
        if [ \! -e "${single_conf}" ];then
            generate_conf_d_file
        fi
        
        sudo a2dissite $LAVA_INSTANCE.conf
        if [ "`ls -A /etc/apache2/sites-enabled/`" = "" ]; then
            sudo a2ensite 000-default
        fi

        sudo ln -s ${single_conf} /etc/apache2/conf.d/${LAVA_INSTANCE}.conf
        sed -i "s/    \"MEDIA_URL\": \"\/media\/\",/    \"MEDIA_URL\": \"\/${LAVA_INSTANCE}-media\/\"\,/" ${settings_file} 
        sed -i "s/    \"STATIC_URL\": \"\/static\/\",/    \"STATIC_URL\": \"\/${LAVA_INSTANCE}-static\/\",/" ${settings_file}
        sed -i "s/    \"LOGIN_URL\": \"\/accounts\/login\/\",/    \"LOGIN_URL\": \"\/${LAVA_INSTANCE}\/accounts\/login\/\",/" ${settings_file}
        sed -i "s/    \"LOGIN_REDIRECT_URL\": \"\/\",/    \"LOGIN_REDIRECT_URL\": \"\/${LAVA_INSTANCE}\",/" ${settings_file}
        touch ${reload_file}
        return 0
    else
        echo 'target must be specified with "vhost" or "location"'
        return 1
    fi
}


cmd_toggle(){
    LAVA_INSTANCE=$1
    TARGET=${2:vhost}
    _banner
    
    toggle_instance ${LAVA_INSTANCE} ${TARGET}
    if [ $? -eq 0 ]; then
        sudo service apache2 restart
    fi
}


cmd_toggle_all(){
    TARGET=${1:vhost}

    _banner
   
    if [ "X${TARGET}" != "Xvhost"  -a  "X${TARGET}" != "Xlocation" ]; then
        echo 'Please specify the target with "vhost" or "location"'
        return 1
    fi

    INSTANCES=`ls $LAVA_PREFIX`
    if [ "X${INSTANCES}" = "X" ]; then
        return
    fi
    need_restart_apache=false
    for instance in ${INSTANCES}; do
        is_vhost_value=`is_vhost ${instance}`
        if [ "X${TARGET}" = "X${is_vhost_value}" ]; then
            continue
        fi
        if [ "X${TARGET}" = "Xunknown" ]; then
            continue
        fi
        printf "Start to change instance(%s) to %s\n" ${instance} ${TARGET}
        toggle_instance ${instance} ${TARGET}
        if [ $? -eq 0 ]; then
            need_restart_apache=true
            printf "Change instance(%s) to %s successfully\n" ${instance} ${TARGET}
        else
            printf "Change instance(%s) to %s failed\n" ${instance} ${TARGET}
        fi
    done
    if ${need_restart_apache}; then
        sudo service apache2 restart
    fi
}

usage() {
    cat <<END_OF_USAGE
Usage: ${__FILE_NAME__} <command> [options]"

Key commands:"
    setup   - prepare machine for LAVA (prerequisites)"
              (do this once before trying out others)"
Commands for working with instances:"
    list    - list all instances installed"
    bundle  - create a bundle in preparation for installing"
              or updating"
    install - install LAVA instance"
    upgrade - upgrade LAVA instance"
    remove  - remove LAVA instance (undoes install)"
    toggle  - toggle one LAVA instance between being"
            - referenced by the location (aka "
              insance name) or by the vhost"
              * vhost site: the instance is configured with"
                  VirtualHost directive of apache"
                  (ex. http://vhost.example.com)"
              * location site: the instance is configured"
                  with Location directive of apache"
                  (ex. http://localhost/instance_name)"
            - With the location site we can deploy multiple"
            - instances on a single IP machine, while with"
            - the vhost site we need have multiple hostnames"
            - or IPs for deploying multiple instances"
            - run ${__FILE_NAME__} toggle \$instance [location|vhost]"
    toggle_all  - toggle all LAVA instances one time between"
            - used as location site or used as vhost site"
            - like toggle command"
            - run ${__FILE_NAME__} toggle_all [location|vhost]"
Commands for working with data:"
    backup  - backup your data"
    restore - restore earlier backup (removes current data)"
Commands for working at lower level:"
    manage  - run lava-server management commands"

Options:"

-d, --developer-mode"
  Sets developer mode. During installation of an instance,"
  if developer mode is turned the instance will be configured"
  to be run with the Django DEBUG setting turned on"

-n, --non-interactive"
  Runs non-interactively. Default answers for all questions"
  will be assumed."

See the README file for instructions"
END_OF_USAGE
}


main() {
    os_check
    uid_check
    if [ $LAVA_SUPPORTED = 0 ]; then
        echo "LAVA is not supported on this system"
        echo "------------------------------------"
        echo "Please report a bug on lava-deployment-tool"
        echo "https://bugs.launchpad.net/lava-deployment-tool/+filebug"
        echo
        echo "Please provide the following information"
        echo 
        lsb_release -a
        exit 1
    fi

    if [ -n "$1" ]; then
        cmd="$1"
        shift
    else
        cmd=help
    fi

    options="
        -o nd
        --long non-interactive
        --long developer-mode
    "
    TEMP="$(getopt --name ${__FILE_NAME__} $options -- "$@")"
    getopt_status=$?
    if [ $getopt_status -ne 0 ]; then
        exit $getopt_status
    fi
    eval set -- "$TEMP"

    while :; do
        arg="$1"
        shift
        case "$arg" in
            --non-interactive|-n)
                LAVA_NON_INTERACTIVE=yes
                ;;
            --developer-mode|-d)
                LAVA_DEV_MODE=yes
                ;;
            --)
                break;;
        esac
    done

    case "$cmd" in
        ^$|help)
            usage
            ;;
        setup)
            cmd_setup "$@"
            ;;
        install|upgrade|remove|preview)
            cmd_$cmd "$@" # 2>&1 | tee "$cmd-log-for-instance-$LAVA_INSTANCE.log"
            ;;
        manage)
            cmd_manage "$@"
            ;;
        backup)
            cmd_backup "$@"
            ;;
        restore-*)
            cmd_$cmd "$@"
            ;;
        install_*)
            set -x
            set -e
            _load_configuration "$@"
            $cmd
            set +x
            set +e
            ;;
        bundle)
            cmd_bundle "$@"
            ;;
        toggle)
            cmd_toggle "$@"
            ;;
        toggle_all)
            cmd_toggle_all "$@"
            ;;
        list)
            cmd_list "$@"
            ;;
        version)
            echo "LAVA Deployment Tool, version $LAVA_DEPLOYMENT_TOOL_VERSION."
            ;;
        *)
            echo "Unknown command: $cmd, try help"
            exit 1
            ;;
    esac
}

__FILE_NAME__=`basename ${0}`
main "$@"
