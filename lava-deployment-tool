#!/bin/bash
LAVA_DEPLOYMENT_TOOL_VERSION="0.4"

# Global Configuration

# Where all LAVA stuff is kept, this is meant to make /srv/lava extensible in the future
LAVA_ROOT=/srv/lava

# All LAVA instances are created relative to this path
LAVA_PREFIX=$LAVA_ROOT/instances

# Pip download cache 
export PIP_DOWNLOAD_CACHE=$LAVA_ROOT/.downloads

test -n "$http_proxy" && PIP_PROXY_OPTION="--proxy=$http_proxy"

# All LAVA uses this python version
LAVA_PYTHON=python2.6

# All of LAVA is being served by this uWSGI version
LAVA_UWSGI=1.0.3

# Current version of setup required by lava (global state)
export LAVA_SETUP_REQUIRED_VERSION=20

# Check if this installation is supported
export LAVA_SUPPORTED=0

# Installation and configuration steps (all the wizard_xxx install_xxx functions)
LAVA_INSTALL_STEPS="user fs venv database broker web_hosting app config_app"


os_check() {
    case `lsb_release -i -s` in
        Ubuntu)
            case `lsb_release -c -s` in
                lucid)
                    export LAVA_PYTHON=python2.6
                    # FIXME: Lucid is not supported
                    export LAVA_SUPPORTED=0
                    # Required system packages
                    LAVA_PKG_LIST="whiptail python-virtualenv python-pip git-core build-essential $LAVA_PYTHON-dev libxml2-dev apache2 apache2-dev postgresql rabbitmq-server mercurial"
                    ;;
                oneiric|precise)
                    export LAVA_PYTHON=python2.7
                    export LAVA_SUPPORTED=1
                    LAVA_PKG_LIST="whiptail python-virtualenv python-pip git build-essential $LAVA_PYTHON-dev libxml2-dev apache2 apache2-dev postgresql rabbitmq-server mercurial"
                    ;;
            esac
            ;;
    esac
}


uid_check() {
    if [ $(id -u) = 0 ]; then
        echo "Running as root is not supported"
        exit 1
    fi
}


_load_configuration() {
    LAVA_INSTANCE=$1

    # Persistent config
    if [ -e $LAVA_PREFIX/$LAVA_INSTANCE/instance.conf ]; then
        . $LAVA_PREFIX/$LAVA_INSTANCE/instance.conf
        # TODO: ensure we have all essential variables or we die verbosely
    else
        # Legacy configs, no lava- prefix
        export LAVA_SYS_USER=$LAVA_INSTANCE
        export LAVA_DB_USER=$LAVA_INSTANCE
        export LAVA_DB_NAME=$LAVA_INSTANCE
        # Single static vhost
        export LAVA_RABBIT_VHOST=/
    fi

    export LAVA_SYS_USER
    export LAVA_DB_USER
    export LAVA_DB_NAME
    export LAVA_RABBIT_VHOST
}


_show_config() {
    cat <<INSTANCE_CONF
# Installation prefix
LAVA_PREFIX='$LAVA_PREFIX'
# Instance name
LAVA_INSTANCE='$LAVA_INSTANCE'
# System configuration (Unix-level)
LAVA_SYS_USER='$LAVA_SYS_USER'
# Apache configuration
LAVA_APACHE_VHOST='$LAVA_APACHE_VHOST'
LAVA_DEV_MODE='$LAVA_DEV_MODE'
# PostgreSQL configuration
LAVA_DB_NAME='$LAVA_DB_NAME'
LAVA_DB_USER='$LAVA_DB_USER'
LAVA_DB_PASSWORD='$LAVA_DB_PASSWORD'
# RabbitMQ configuration
LAVA_RABBIT_VHOST='$LAVA_RABBIT_VHOST'
LAVA_RABBIT_USER='$LAVA_RABBIT_USER'
LAVA_RABBIT_PASSWORD='$LAVA_RABBIT_PASSWORD'
# Scheduler configuration
LAVA_SCHEDULER_ENABLED='$LAVA_SCHEDULER_ENABLED'
LAVA_SERVER_IP='$LAVA_SERVER_IP'
LAVA_PROXY='$LAVA_PROXY'
INSTANCE_CONF
}


_save_config() {
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/
    cat >$LAVA_PREFIX/$LAVA_INSTANCE/instance.conf <<INSTANCE_CONF
# Installation prefix
LAVA_PREFIX='$LAVA_PREFIX'
# Instance name
LAVA_INSTANCE='$LAVA_INSTANCE'
# System configuration (Unix-level)
LAVA_SYS_USER='$LAVA_SYS_USER'
# Apache configuration
LAVA_APACHE_VHOST='$LAVA_APACHE_VHOST'
LAVA_DEV_MODE='$LAVA_DEV_MODE'
# PostgreSQL configuration
LAVA_DB_NAME='$LAVA_DB_NAME'
LAVA_DB_USER='$LAVA_DB_USER'
LAVA_DB_PASSWORD='$LAVA_DB_PASSWORD'
# RabbitMQ configuration
LAVA_RABBIT_VHOST='$LAVA_RABBIT_VHOST'
LAVA_RABBIT_USER='$LAVA_RABBIT_USER'
LAVA_RABBIT_PASSWORD='$LAVA_RABBIT_PASSWORD'
# Scheduler configuration
LAVA_SCHEDULER_ENABLED='$LAVA_SCHEDULER_ENABLED'
INSTANCE_CONF
}



_configure() {
    set +x
    export LAVA_INSTANCE="$1"
    # Defaults
    for install_step in $LAVA_INSTALL_STEPS; do
        defaults_$install_step
    done
    # Wizard loop
    while true; do
        echo "Instance Configuration"
        echo "----------------------"
        echo
        echo "Before configuring your instance we need to ask you a few questions"
        echo "The defaults are safe so feel free to use them without any changes"
        # Wizard page loop
        num_steps=1
        for install_step in $LAVA_INSTALL_STEPS; do
            while true; do
                echo
                echo "Note: it is safe to CTRL-C at this stage!"
                wizard_$install_step && break
            done
        done
        echo
        echo "Configuration summary"
        echo "---------------------"
        echo
        _show_config
        echo
        # Response loop
        while true; do
            echo "(it is safe to CTRL-C at this stage!)"
            read -p "Is everything okay? (yes|no) " RESPONSE
            case "$RESPONSE" in
                yes|no)
                    break
                    ;;
            esac
        done
        if [ "$RESPONSE" = "yes" ]; then
            echo "Saving configuration"
            _save_config
            echo "Configuration done"
            break
        else
            echo "Going back to wizard"
            continue
        fi
    done
    set -x
}


_install() {
    for install_step in $LAVA_INSTALL_STEPS; do 
        echo "Running installation step $install_step"
        install_$install_step || die "Failed at $install_step"
    done
    echo "All installation is done"
}


defaults_user() {
    export LAVA_SYS_USER=lava-$LAVA_INSTANCE
}


pkglist_user() {
    true
}


wizard_user() {
    export LAVA_SYS_USER_DESC="User for LAVA instance $LAVA_INSTANCE"

    echo
    echo "User account configuration"
    echo "^^^^^^^^^^^^^^^^^^^^^^^^^^"
    echo
    echo "We need to create a system user for this instance:"
    echo "System user account configuration"
    echo
    echo "User name:        '$LAVA_SYS_USER'"
    echo "User description: '$LAVA_SYS_USER_DESC'"
    echo
    echo "next   - Use the user name as is"
    echo "edit   - Edit the user name"

    read -p "Please please decide what to do: " RESPONSE

    case "$RESPONSE" in
        next)
            return 0  # loop complete
            ;;
        edit)
            read -p "New user name: " LAVA_SYS_USER_NEW
            if test -n "$LAVA_SYS_USER_NEW" && echo "$LAVA_SYS_USER_NEW" | grep -q -E -e '[a-z]+[-a-z0-9]*'; then
                echo "New user name is '$LAVA_SYS_USER_NEW'"
                LAVA_SYS_USER="$LAVA_SYS_USER_NEW" 
            else
                echo "Incorrect user name. It must be a simple ascii identifier"
            fi
            ;;
    esac
    return 1  # another loop please
}


install_user() {
    logger "Creating system user for LAVA instance $LAVA_INSTANCE: $LAVA_SYS_USER"
    echo "Creating system user for LAVA instance $LAVA_INSTANCE: $LAVA_SYS_USER"
    sudo useradd --system --comment "$LAVA_SYS_USER_DESC" "$LAVA_SYS_USER"
}


defaults_fs() {
    true
}


pkglist_fs() {
    true
}


wizard_fs() {
    echo
    echo "Filesystem configuration"
    echo "^^^^^^^^^^^^^^^^^^^^^^^^"
    echo
    echo "We need filesystem location for this instance"
    echo
    echo "Installation directory: $LAVA_PREFIX/$LAVA_INSTANCE"
    echo
    echo "Note: everything apart from the database and message"
    echo "broker state will be stored there"
    echo
    echo "(this is just a notification, it is not configurable)"
    echo
    echo "next    - continue"

    read -p "Please decide what to do: " RESPONSE

    case "$RESPONSE" in
        next)
            return 0  # loop complete
    esac
    return 1  # another loop please
}


install_fs() {
    logger "Creating filesystem structure for LAVA instance $LAVA_INSTANCE"
    # Create basic directory structure
    # Apache application:
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/etc/apache2/conf.d
    # Apache site:
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/etc/apache2/sites-available
    # Dispatcher configuration 
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-dispatcher
    # Dashboard reports
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/reports
    # Dashboard data views
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/views
    # Custom templates
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/templates
    # Static file cache
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/var/www/lava-server/static
    # Lava-dispatcher folders
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/var/cache/lava-dispatcher
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/var/www/lava-server/images
    # Repository of precious user-generated data (needs backup)
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/var/lib/lava-server/media
    # Celery state 
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/var/lib/lava-celery
    # Log files
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/var/log
    # Sockets and other runtime stuff
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/run
    # Source code (used when tracking trunk)
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/src
    # Temporary files
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/tmp

    # Allow apache (running as www-data) to read our public web files 
    sudo chgrp -R www-data $LAVA_PREFIX/$LAVA_INSTANCE/var/www/lava-server/
    sudo chmod -R g+rXs $LAVA_PREFIX/$LAVA_INSTANCE/var/www/lava-server/
    # Allow instance user to read all lava-server settings
    sudo chgrp -R $LAVA_SYS_USER $LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server
    sudo chmod -R g+rXs $LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/
    # Allow instance to write to media directory
    sudo chgrp -R $LAVA_SYS_USER $LAVA_PREFIX/$LAVA_INSTANCE/var/lib/lava-server/
    sudo chmod -R g+rwXs $LAVA_PREFIX/$LAVA_INSTANCE/var/lib/lava-server/
    # Prevent anyone else from reading from the media directory
    sudo chmod -R o-rX $LAVA_PREFIX/$LAVA_INSTANCE/var/lib/lava-server/
    # Allow instance to store lava-celery state 
    sudo chgrp -R $LAVA_SYS_USER $LAVA_PREFIX/$LAVA_INSTANCE/var/lib/lava-celery/
    sudo chmod -R g+rwXs $LAVA_PREFIX/$LAVA_INSTANCE/var/lib/lava-celery/
    # Allow instance user to put stuff in runtime directory
    # and allow www-data to read from that directory
    sudo chown -R $LAVA_SYS_USER:www-data $LAVA_PREFIX/$LAVA_INSTANCE/run
    sudo chmod -R g+rXs $LAVA_PREFIX/$LAVA_INSTANCE/run
    # Allow instance to log stuff to log directory
    # Allow users in the adm group to read those logs
    sudo chown -R $LAVA_SYS_USER:adm $LAVA_PREFIX/$LAVA_INSTANCE/var/log
    sudo chmod -R g+rXs $LAVA_PREFIX/$LAVA_INSTANCE/var/log
    # Allow instance user to put stuff in temporary directory
    # Set the sticky and setgid bits there
    sudo chgrp -R $LAVA_SYS_USER $LAVA_PREFIX/$LAVA_INSTANCE/tmp
    sudo chmod -R g+rwtXs $LAVA_PREFIX/$LAVA_INSTANCE/tmp
}


defaults_venv() {
    true
}

pkglist_venv() {
    echo "https://github.com/zyga/pip/tarball/develop"
}


wizard_venv() {
    echo
    echo "Python virtual environment configuration"
    echo "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
    echo
    echo "We will use python virtualenv to isolate LAVA code from your system"
    echo
    echo "Python version: $LAVA_PYTHON"
    echo
    echo "You can interact with this source code (installation) as if it"
    echo "was globally by invoking the following line:"
    echo
    echo "$ . $LAVA_PREFIX/$LAVA_INSTANCE/bin/activate"
    echo
    echo "(Note that the intent is to source (read) the file, not execute it)"
    echo "When you are done just type:"
    echo
    echo "$ deactivate"
    echo
    echo "While inside your virtualenv you can invoke additional commands,"
    echo "most notably, lava-server manage ..."
    echo 
    echo "(this is just a notification, it is not configurable)"
    echo
    echo "next    - continue"

    read -p "Please decide what to do: " RESPONSE

    case "$RESPONSE" in
        next)
            return 0  # loop complete
    esac
    return 1  # another loop please
}


install_venv() {
    logger "Creating virtualenv using $LAVA_PYTHON for LAVA instance $LAVA_INSTANCE"

    # Create virtualenv
    virtualenv --no-site-packages --distribute $LAVA_PREFIX/$LAVA_INSTANCE -p $LAVA_PYTHON
}


defaults_database() {
    export LAVA_DB_NAME="lava-$LAVA_INSTANCE"
    export LAVA_DB_USER="lava-$LAVA_INSTANCE"
    export LAVA_DB_PASSWORD=$(dd if=/dev/urandom bs=1 count=128 2>/dev/null | md5sum | cut -d ' ' -f 1)
}


pkglist_database() {
    echo psycopg2 
}


wizard_database() {
    echo
    echo "PostgreSQL configuration"
    echo "^^^^^^^^^^^^^^^^^^^^^^^^"
    echo
    echo "We will use PostgreSQL to store application state"
    echo "(apart from files that are just files in your filesystem)"
    echo
    echo "Database name: $LAVA_DB_NAME"
    echo "Database user: $LAVA_DB_USER"
    echo "     password: $LAVA_DB_PASSWORD (automatically generated)"
    echo
    echo "(this is just a notification, it is not configurable)"
    echo
    echo "next    - continue"

    read -p "Please decide what to do: " RESPONSE

    case "$RESPONSE" in
        next)
            return 0  # loop complete
    esac
    return 1  # another loop please
}


install_database()
{
    logger "Creating database configuration for LAVA instance $LAVA_INSTANCE"

    # Create database configuration file
    cat >$LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/default_database.conf <<DEFAULT_DATABASE_CONF
dbuser='$LAVA_DB_USER'
dbpass='$LAVA_DB_PASSWORD'
basepath=''
dbname='$LAVA_DB_NAME'
dbserver=''
dbport=''
dbtype='pgsql'
DEFAULT_DATABASE_CONF

    # Create database user
    sudo -u postgres createuser \
        --no-createdb \
        --encrypted \
        --login \
        --no-superuser \
        --no-createrole \
        --no-password \
        "$LAVA_DB_USER" \
        || die "Failed to create database user"

    # Set a password for our new user
    sudo -u postgres psql \
        --quiet \
        --command="ALTER USER \"$LAVA_DB_USER\" WITH PASSWORD '$LAVA_DB_PASSWORD'" \
        || die "Failed to set database password"

    # Create a database for our new user
    sudo -u postgres createdb \
        --encoding=UTF-8 \
        --owner="$LAVA_DB_USER" \
        --template=template0 \
        --no-password \
        "$LAVA_DB_NAME" \
        || die "Failed to create a database"
}


defaults_broker() {
    export LAVA_RABBIT_VHOST="/lava-$LAVA_INSTANCE"
    export LAVA_RABBIT_USER="lava-$LAVA_INSTANCE"
    export LAVA_RABBIT_PASSWORD=$(dd if=/dev/urandom bs=1 count=128 2>/dev/null | md5sum | cut -d ' ' -f 1)
}


pkglist_broker() {
    true
}


wizard_broker() {
    echo
    echo "RabbitMQ configuration"
    echo "^^^^^^^^^^^^^^^^^^^^^^"
    echo
    echo "We will use RabbitMQ to coordinate the distributed state"
    echo "of various LAVA components. For isolation each instance"
    echo "has a separate 'virtual host' created inside RabbitMQ'"
    echo "and runs as a separate RabbitMQ user (this is not a"
    echo "system user account) and password"
    echo
    echo "Broker vhost: $LAVA_RABBIT_VHOST"
    echo "Broker user:  $LAVA_RABBIT_USER"
    echo "   password:  $LAVA_RABBIT_PASSWORD (automatically generated)"
    echo
    echo "(this is just a notification, it is not configurable)"
    echo
    echo "next    - continue"

    read -p "Please decide what to do: " RESPONSE

    case "$RESPONSE" in
        next)
            return 0  # loop complete
    esac
    return 1  # another loop please
}


install_broker() {
    set -x
    sudo rabbitmqctl add_user "$LAVA_RABBIT_USER" "$LAVA_RABBIT_PASSWORD"
    sudo rabbitmqctl add_vhost "$LAVA_RABBIT_VHOST"
    sudo rabbitmqctl set_permissions -p "$LAVA_RABBIT_VHOST" "$LAVA_RABBIT_USER" ".*" ".*" ".*"
    set +x
}


defaults_web_hosting() {
    export LAVA_APACHE_VHOST=$(hostname)
    export LAVA_DEV_MODE=no
}


pkglist_web_hosting() {
    echo "http://projects.unbit.it/downloads/uwsgi-$LAVA_UWSGI.tar.gz"
    echo "django-seatbelt"
    echo "django-debian"
    echo "django-celery"
}


wizard_web_hosting() {
    echo
    echo "Apache and uWSGI configuration"
    echo "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
    echo
    echo "We will use Apache 2 to serve static application files"
    echo "Apache will also use mod uWSGI to talk to the application"
    echo "servers running LAVA code"
    echo
    echo "Normally we use django-seatbelt to prevent importing code"
    echo "from outside of each instance (for isolation and reliability)"
    echo "but this may be annoying when you do development and have"
    echo "some code in your \$HOME directory."
    echo
    echo "Developer mode: $LAVA_DEV_MODE"
    echo
    echo "next    - continue"
    echo "dev     - toggle developer mode"

    read -p "Please decide what to do: " RESPONSE

    case "$RESPONSE" in
        next)
            return 0  # loop complete
            ;;
        dev)
            if [ $LAVA_DEV_MODE = yes ]; then
                LAVA_DEV_MODE=no
            else
                LAVA_DEV_MODE=yes
            fi
            return 1
            ;;
    esac
    return 1  # another loop please
}

generate_conf_d_file(){
    # Create apache2 instance configuration for single IP machine
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/etc/apache2/conf.d/ 
    cat >$LAVA_PREFIX/$LAVA_INSTANCE/etc/apache2/conf.d/${LAVA_INSTANCE}.conf <<INSTANCE_FOR_SINGLE_IP

# set the static files directory for this instance
Alias  /${LAVA_INSTANCE}-static/ $LAVA_PREFIX/$LAVA_INSTANCE/var/www/lava-server/static/

# Allow serving media, static and other custom files
<Directory $LAVA_PREFIX/$LAVA_INSTANCE/var/www>
    Options FollowSymLinks
    AllowOverride None
    Order allow,deny
    allow from all
</Directory>

# uWSGI mount point. For this to work the uWSGI module needs be loaded.
# XXX: Perhaps we should just load it ourselves here, dunno.
<Location /${LAVA_INSTANCE}>
    SetHandler              uwsgi-handler
    uWSGISocket             $LAVA_PREFIX/$LAVA_INSTANCE/run/uwsgi.sock
</Location>

INSTANCE_FOR_SINGLE_IP
}


install_web_hosting() {
    logger "Installing uWSGI and other hosting parts for LAVA instance $LAVA_INSTANCE"

    if [ \! -e /etc/apache2/mods-available/uwsgi.load ]; then
        logger "Building uWSGI apache module..."
        # NOTE: we may not have this file cached as we used bundle to get it
        if [ ! -e $PIP_DOWNLOAD_CACHE/http%3A%2F%2Fprojects.unbit.it%2Fdownloads%2Fuwsgi-$LAVA_UWSGI.tar.gz ]; then
            pip install $PIP_PROXY_OPTION --no-install http://projects.unbit.it/downloads/uwsgi-$LAVA_UWSGI.tar.gz || die "Failed to download uWSGI"
        fi
        ( cd $LAVA_PREFIX/$LAVA_INSTANCE/tmp && tar zxf $PIP_DOWNLOAD_CACHE/http%3A%2F%2Fprojects.unbit.it%2Fdownloads%2Fuwsgi-$LAVA_UWSGI.tar.gz )
        ( cd $LAVA_PREFIX/$LAVA_INSTANCE/tmp/uwsgi-$LAVA_UWSGI/apache2 && sudo apxs2 -c -i -a mod_uwsgi.c )
    fi

    if [ "$LAVA_DEV_MODE" = "yes" ]; then
        cat >$LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/lava-server.wsgi <<INSTANCE_WSGI
# This file was automatically generated by lava-deployment-tool.sh
import os

# Force django to use the specified settings module.
os.environ['DJANGO_SETTINGS_MODULE'] = 'lava_server.settings.debian'
# And force django-debian to look at our instance-specific configuration directory
os.environ['DJANGO_DEBIAN_SETTINGS_TEMPLATE'] = '$LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/{filename}.conf'

# Setup django WSGI handler
import django.core.handlers.wsgi

application = django.core.handlers.wsgi.WSGIHandler()
INSTANCE_WSGI
    else
        cat >$LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/lava-server.wsgi <<INSTANCE_WSGI
# This file was automatically generated by lava-deployment-tool.sh
import os
import sys
from django_seatbelt import seatbelt

# We need those to get stuff like threading that seems not to be supported when
# running virtualenv. Despite virtualenv setting up symlinks for some of the
# .so files this one does not seem to work. More insight on if this is really
# the case welcome.
core_python_paths = [
    "/usr/lib/$LAVA_PYTHON",
    "/usr/lib/$LAVA_PYTHON/lib-dynload"]

# Construct new path starting with core python, followed by the rest
sys.path = core_python_paths + [path for path in sys.path if path not in core_python_paths]

# Filter path, allow only core python paths and prefix paths (no local/user/junk)
def allow_core_python(path):
    return path in core_python_paths

# In virtualenv sys.prefix points to the root of the virtualenv, outside it
# points to the prefix of the system python installation (typically /usr)
def allow_sys_prefix(path):
    return path.startswith(sys.prefix)

# seatbelt.solder filters sys.path according to the callbacks specified below.
seatbelt.solder(allow_callbacks=[allow_sys_prefix, allow_core_python])

# Print summary (for debugging)
# print "sys.prefix:", sys.prefix
# print "sys.path:"
# for path in sys.path:
#    print " - %s" % path

# Force django to use the specified settings module.
os.environ['DJANGO_SETTINGS_MODULE'] = 'lava_server.settings.debian'
# And force django-debian to look at our instance-specific configuration directory
os.environ['DJANGO_DEBIAN_SETTINGS_TEMPLATE'] = '$LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/{filename}.conf'

# Setup django WSGI handler
import django.core.handlers.wsgi

# NOTE: Here one might also use applications = {'/': application} to define
# namespace mapping. I'm not sure if this is used by uWSGI or by any handler
# but I found that in the docs to uWSGI.
application = django.core.handlers.wsgi.WSGIHandler()
INSTANCE_WSGI
    fi

    # Create apache2 site
    cat >$LAVA_PREFIX/$LAVA_INSTANCE/etc/apache2/sites-available/lava-server.conf <<INSTANCE_SITE
<VirtualHost *:80>
    ServerAdmin webmaster@localhost
    ServerName $LAVA_APACHE_VHOST

    # Allow serving media, static and other custom files
    <Directory $LAVA_PREFIX/$LAVA_INSTANCE/var/www>
        Options FollowSymLinks
        AllowOverride None
        Order allow,deny
        allow from all
    </Directory>

    # This is a small directory with just the index.html file that tells users
    # about this instance has a link to application pages
    DocumentRoot        $LAVA_PREFIX/$LAVA_INSTANCE/var/www/lava-server

    # uWSGI mount point. For this to work the uWSGI module needs be loaded.
    # XXX: Perhaps we should just load it ourselves here, dunno.
    <Location />
        SetHandler              uwsgi-handler
        uWSGISocket             $LAVA_PREFIX/$LAVA_INSTANCE/run/uwsgi.sock
    </Location>

    # Make exceptions for static and media.
    # This allows apache to serve those and offload the application server
    <Location /static>
        SetHandler      none
    </Location>
    # We don't need media files as those are private in our implementation
 
    # images folder for lava-dispatcher tarballs
    <Location /images>
        SetHandler      none
    </Location>


</VirtualHost>
INSTANCE_SITE

    sudo ln -s $LAVA_PREFIX/$LAVA_INSTANCE/etc/apache2/sites-available/lava-server.conf /etc/apache2/sites-available/$LAVA_INSTANCE.conf

    generate_conf_d_file

    # Create reload file
    echo "Touching this file will gracefully restart uWSGI worker for LAVA instance: $LAVA_INSTANCE" > $LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/uwsgi.reload

    # Create uWSGI configuration file
    cat >$LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/uwsgi.ini <<UWSGI_INI
[uwsgi]
home = $LAVA_PREFIX/$LAVA_INSTANCE
socket = $LAVA_PREFIX/$LAVA_INSTANCE/run/uwsgi.sock
chmod-socket = 660
wsgi-file = $LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/lava-server.wsgi
master = true
workers = 8
logto = $LAVA_PREFIX/$LAVA_INSTANCE/var/log/lava-uwsgi.log
log-master = true
auto-procname = true
touch-reload = $LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/uwsgi.reload
gid = $LAVA_SYS_USER
uid = $LAVA_SYS_USER
UWSGI_INI

    sudo a2ensite $LAVA_INSTANCE.conf
    sudo a2dissite 000-default || true
    sudo service apache2 restart
}


defaults_app() {
    true
}


pkglist_app() {
    cat $LAVA_REQUIREMENT
}


wizard_app() {
    echo
    echo "LAVA application configuration"
    echo "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
    echo
    return 0
}


install_app() {
    echo "Installing/upgrading application code from $LAVA_BUNDLE file"

    # Clean all builds to allow package upgrading
    rm -rf $LAVA_PREFIX/$LAVA_INSTANCE/build/*
    . $LAVA_PREFIX/$LAVA_INSTANCE/bin/activate
    set -x
    pip install --upgrade $PIP_PROXY_OPTION "$LAVA_BUNDLE" || die "Failed to install application bundle"
    set +x
    deactivate

    gen_lava_dispatcher_config

    if [ ! -e $LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/settings.conf ]; then
        if [ -e $LAVA_PREFIX/$LAVA_INSTANCE/src/lava-server ]; then
            # We're in editable server mode, let's use alternate paths for tempates and static files
            echo "Generating $LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/settings.conf for DEVELOPMENT"
            echo "This means that lava-server (which has to be special) is installed in editable mode"
            echo "Some of the paths will refer to $LAVA_PREFIX/$LAVA_INSTANCE/src/lava-server."
            echo "Even if you later on upgrade to non-editable lava-server those paths"
            echo "will remain to be in use untill you wipe your old config and upgrade again"
            cat >$LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/settings.conf <<SETTINGS_CONF
{
    "DEBUG": false,
    "TEMPLATE_DIRS": [
        "$LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/templates",
        "$LAVA_PREFIX/$LAVA_INSTANCE/src/lava-server/lava_server/templates/"
    ],
    "STATICFILES_DIRS": [
        ["lava-server", "$LAVA_PREFIX/$LAVA_INSTANCE/src/lava-server/lava_server/htdocs/"]
    ],
    "MEDIA_ROOT": "$LAVA_PREFIX/$LAVA_INSTANCE/var/lib/lava-server/media",
    "STATIC_ROOT": "$LAVA_PREFIX/$LAVA_INSTANCE/var/www/lava-server/static",
    "MEDIA_URL": "/media/",
    "STATIC_URL": "/static/",
    "MOUNT_POINT": "/",
    "LOGIN_URL": "/accounts/login/",
    "LOGIN_REDIRECT_URL": "/",
    "BROKER_USER": "$LAVA_RABBIT_USER",
    "BROKER_VHOST": "$LAVA_RABBIT_VHOST",
    "BROKER_PASSWORD": "$LAVA_RABBIT_PASSWORD",
    "DATAREPORT_DIRS": [
        "$LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/reports"
    ],
    "DATAVIEW_DIRS": [
        "$LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/views"
    ]
}
SETTINGS_CONF
        else
            echo "Generating $LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/settings.conf for PRODUCTION"
            cat >$LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/settings.conf <<SETTINGS_CONF
{
    "DEBUG": false,
    "TEMPLATE_DIRS": [
        "$LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/templates",
        "$LAVA_PREFIX/$LAVA_INSTANCE/lib/$LAVA_PYTHON/site-packages/lava_server/templates/"
    ],
    "STATICFILES_DIRS": [
        ["lava-server", "$LAVA_PREFIX/$LAVA_INSTANCE/lib/$LAVA_PYTHON/site-packages/lava_server/htdocs/"]
    ],
    "MEDIA_ROOT": "$LAVA_PREFIX/$LAVA_INSTANCE/var/lib/lava-server/media",
    "STATIC_ROOT": "$LAVA_PREFIX/$LAVA_INSTANCE/var/www/lava-server/static",
    "MEDIA_URL": "/media/",
    "STATIC_URL": "/static/",
    "MOUNT_POINT": "/",
    "LOGIN_URL": "/accounts/login/",
    "LOGIN_REDIRECT_URL": "/",
    "BROKER_USER": "$LAVA_RABBIT_USER",
    "BROKER_VHOST": "$LAVA_RABBIT_VHOST",
    "BROKER_PASSWORD": "$LAVA_RABBIT_PASSWORD",
    "DATAREPORT_DIRS": [
        "$LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/reports"
    ],
    "DATAVIEW_DIRS": [
        "$LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/views"
    ]
}
SETTINGS_CONF
    fi
fi
}


defaults_config_app() {
    export LAVA_SCHEDULER_ENABLED=yes
}


pkglist_config_app() {
    true
}


wizard_config_app() {
    local _question="Do you want to enable the scheduler in this instance?"
    whiptail --title "Enable the scheduler?" --yesno "$_question" 10 40 && LAVA_SCHEDULER_ENABLED=yes || LAVA_SCHEDULER_ENABLED=no

    local _question="Do you want to config the lava-dispatcher?"
    whiptail --title "Configurate the lava-dispatcher?" --yesno "$_question" 10 40 && LAVA_DISPATCHER_CONFIG=yes || LAVA_DISPATCHER_CONFIG=no
    
    if [ $LAVA_DISPATCHER_CONFIG = yes ]; then
        config_lava_dispatcher
    fi
           
    return 0
}

config_lava_dispatcher() {
    echo "Lava Dispatcher Configuration"
    echo "-----------------------------"

    echo "LAVA_SERVER_IP"
    echo "^^^^^^^^^^^^^^"
    echo "This is the IP the device downloads the image parts from"
    echo ""
    echo "Here is the list of network device on this host"

    ifconfig | grep 'Ethernet\|inet addr'

    while true; do

        read -p "Please enter the IP address: " LAVA_SERVER_IP

        if test -n "$LAVA_SERVER_IP" && echo "$LAVA_SERVER_IP" | grep -q -E -e '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'; then
            echo "The IP address is '$LAVA_SERVER_IP'"
            break
        else
            echo "Incorrect IP address"
        fi
    done

    echo
    echo "LAVA_PROXY"
    echo "^^^^^^^^^^"

    echo "This is the address and port of cache proxy service, format is like:"
    echo "http://192.168.1.10:3128/"
    read -p "Please enter the URL: " LAVA_PROXY


    # Location for rootfs/boot tarballs extracted from images
    export LAVA_IMAGE_TMPDIR=$LAVA_PREFIX/$LAVA_INSTANCE/var/www/lava-server/images

    # URL where LAVA_IMAGE_TMPDIR can be accessed remotely
    export LAVA_IMAGE_URL=http://$SERVER_IP/lava-server/images

    # Location on the device for storing test results.
    export LAVA_RESULT_DIR=$LAVA_PREFIX/$LAVA_INSTANCE/tmp

    # Location for caching downloaded artifacts such as hwpacks and images
    export LAVA_CACHEDIR=$LAVA_PREFIX/$LAVA_INSTANCE/var/cache/lava-dispatcher

}

gen_lava_dispatcher_config() {
    LAVA_DISPATCHER_CONFIG_FILE=$LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-dispatcher/lava-dispatcher.conf

    if [ -e "${LAVA_DISPATCHER_CONFIG_FILE}" ]; then
        echo "Not overwriting lava-dispatcher config file $LAVA_DISPATCHER_CONFIG_FILE"
        return
    fi

    echo "Creating lava-dispatcher config file $LAVA_DISPATCHER_CONFIG_FILE"
    sudo sh -c "cat >$LAVA_DISPATCHER_CONFIG_FILE" <<LAVA_DISPATCHER_CONF
# This file was automatically generated by lava-deployment-tool.sh

LAVA_SERVER_IP = $LAVA_SERVER_IP

# Location for rootfs/boot tarballs extracted from images
LAVA_IMAGE_TMPDIR = $LAVA_IMAGE_TMPDIR

# URL where LAVA_IMAGE_TMPDIR can be accessed remotely
LAVA_IMAGE_URL = http://%(LAVA_SERVER_IP)s/images

# Location on the device for storing test results.
LAVA_RESULT_DIR = $LAVA_RESULT_DIR

# Location for caching downloaded artifacts such as hwpacks and images
LAVA_CACHEDIR = $LAVA_CACHEDIR

# This is the address and port of cache proxy service, format is like:
# LAVA_PROXY = http://192.168.1.10:3128/
LAVA_PROXY = $LAVA_PROXY

# The url point to the version of lava-test to be install with pip
#LAVA_TEST_URL = bzr+http://bazaar.launchpad.net/~le-chi-thu/lava-test/enabled-file-cache/#egg=lava-test

# Python logging level to use
# # 10 = DEBUG
# # 20 = INFO
# # 30 = WARNING
# # 40 = ERROR
# # Messages with a lower number than LOGGING_LEVEL will be suppressed
# LOGGING_LEVEL = 10

LAVA_DISPATCHER_CONF

}

install_config_app() {
    # Enable virtualenv
    . $LAVA_PREFIX/$LAVA_INSTANCE/bin/activate

    if [ "${LAVA_SCHEDULER_ENABLED-x}" = "x" ]; then
        # LAVA_SCHEDULER_ENABLED was not in the config.
        # Set it to 'yes' as that was the assumed behaviour before
        # LAVA_SCHEDULER_ENABLED was introduced.
        echo "Setting LAVA_SCHEDULER_ENABLED to 'yes'..."
        export LAVA_SCHEDULER_ENABLED='yes'
        _save_config
    fi

    echo "Building cache of static files..."
    set -x
    lava-server manage \
        --instance-template=$LAVA_ROOT/instances/{instance}/etc/lava-server/{{filename}}.conf \
        --instance=$LAVA_INSTANCE \
        build_static --noinput --link || die "Failed to update the cache of static content"
    set +x

    echo "Stopping instance for database changes..."
    set -x
    sudo stop lava-instance LAVA_INSTANCE=$LAVA_INSTANCE || true # in case of upgrades
    set +x

    echo "Synchronizing database..."
    set -x
    lava-server manage \
        --instance-template=$LAVA_ROOT/instances/{instance}/etc/lava-server/{{filename}}.conf \
        --instance=$LAVA_INSTANCE \
        syncdb --noinput || die "Failed to synchronize database (run non-migration db updates)"
    set +x

    echo "Running migrations..."
    set -x
    lava-server manage \
        --instance-template=$LAVA_ROOT/instances/{instance}/etc/lava-server/{{filename}}.conf \
        --instance=$LAVA_INSTANCE \
        migrate --noinput || die "Failed to run database migrations"
    set +x

    # Get out of virtualenv
    deactivate

    echo "Starting instance again..."
    set -x
    sudo start lava-instance LAVA_INSTANCE=$LAVA_INSTANCE
    set +x
}


check_min_version() {
    SETUP_VER=0
    if [ -e $LAVA_PREFIX/.setup ]; then
        SETUP_VER=$(cat $LAVA_PREFIX/.setup)
    fi

    if [ $SETUP_VER -lt $LAVA_SETUP_REQUIRED_VERSION ]; then
        die "Please run '$0 setup' first"
    fi
}

cmd_setup() {
    SETUP_VER=0
    if [ -e $LAVA_PREFIX/.setup ]; then
        SETUP_VER=$(cat $LAVA_PREFIX/.setup)
    fi


    if [ $SETUP_VER -lt $LAVA_SETUP_REQUIRED_VERSION ]; then
        echo "===================="
        echo "LAVA Deployment Tool"
        echo "===================="
        echo
        echo "System preparation steps:"
        echo " 1) Installing $LAVA_PKG_LIST"
        echo " 2) Setting up $LAVA_PREFIX owned by you"
        echo " 3) Setting up $PIP_DOWNLOAD_CACHE for downloads"
        echo " 4) Setting up upstart jobs (incuding removal of stale jobs)"
        echo
        read -p "Type YES to continue: " RESPONSE
        test "$RESPONSE" = 'YES' || return
    
        echo "Updating apt cache..."
        sudo apt-get update

        echo "Installing english language pack, if needed"
        # XXX: I'm not 100% sure this is needed
        sudo apt-get install --yes language-pack-en

        # Use English locale, this is VERY important for PostgreSQL locale settings
        # XXX: I don't like en_US.UTF-8, is there any POSIX.UTF-8 we could use?
        echo "Installing essential packages, if needed"
        LANG=en_US.UTF-8 sudo apt-get install --yes $LAVA_PKG_LIST

        echo "Creating LAVA filesystem in $LAVA_PREFIX"
        sudo mkdir -p $LAVA_PREFIX
        echo "Making $(whoami) the owner of that location"
        sudo chown $(whoami):$(id -gn) $LAVA_PREFIX 

        echo "Creating PIP download cache in $PIP_DOWNLOAD_CACHE and making it writable"
        sudo mkdir -p $PIP_DOWNLOAD_CACHE
        sudo chown $(whoami):$(id -gn) $PIP_DOWNLOAD_CACHE 

        echo "Creating upstart script for: lava"
        sudo sh -c "cat >/etc/init/lava.conf" <<LAVA_CONF
author "Zygmunt Krynicki"
description "LAVA (abstract task)"

start on runlevel [2345]
stop on runlevel [06]

post-start script
    logger "Started LAVA (all instances)"
end script

post-stop script
    logger "Stopped LAVA (all instances)"
end script
LAVA_CONF

        echo "Creating upstart script for: lava-instances"
        sudo sh -c "cat >/etc/init/lava-instances.conf" <<LAVA_CONF
author "Zygmunt Krynicki"
description "LAVA (instances)"

start on starting lava

task

script
    for dir in \`ls /srv/lava/instances\`; do
        LAVA_INSTANCE=\`basename \$dir\`
# TODO: Check if the instance should start automatically on boot
        if [ -e $LAVA_PREFIX/\$LAVA_INSTANCE/instance.conf ]; then
            start lava-instance LAVA_INSTANCE=\$LAVA_INSTANCE
        fi
    done
end script
LAVA_CONF

        sudo rm -f "/etc/init/lava-uwsgi-workers.conf"

        echo "Creating upstart script for: lava-instance"
        sudo sh -c "cat >/etc/init/lava-instance.conf" <<LAVA_CONF
author "Zygmunt Krynicki"
description "LAVA (instance)"

# Stop when lava is being stopped
stop on stopping lava

# Use LAVA_INSTANCE to differentiate instances
instance \$LAVA_INSTANCE

# Export the instance name so that we can use it in other
# related LAVA jobs.
export LAVA_INSTANCE

pre-start script
    # Don't start unless the instance configuration file is present
    if [ ! -e $LAVA_PREFIX/\$LAVA_INSTANCE/instance.conf ]; then
        stop
    else
        logger "LAVA instance (\$LAVA_INSTANCE) starting..."
    fi
end script

post-start script
    logger "LAVA instance (\$LAVA_INSTANCE) started"
end script

pre-stop script
    logger "LAVA instance (\$LAVA_INSTANCE) stopping..."
end script

post-stop script
    logger "LAVA instance (\$LAVA_INSTANCE) stopped"
end script
LAVA_CONF

        sudo rm -f /etc/init/lava-uwsgi-instance.conf

        echo "Creating upstart script for: lava-instance-uwsgi"
        sudo sh -c "cat >/etc/init/lava-instance-uwsgi.conf" <<LAVA_CONF
author "Zygmunt Krynicki"
description "LAVA uWSGI worker"

# This is an instance job, there are many possible workers
# each with different instance variable.
instance \$LAVA_INSTANCE

# Stop and start along with the rest of the instance
start on starting lava-instance
stop on stopping lava-instance LAVA_INSTANCE=\$LAVA_INSTANCE
# TODO: make uwsgi compatible with upstart socket activation
# start on socket PROTO=unix PATH=$LAVA_PREFIX/\$LAVA_INSTANCE/run/uwsgi.sock

# We want each worker to respawn if it gets hurt.
respawn

# Announce activity
pre-start script
    # Don't start unless the instance configuration file is present
    if [ ! -e $LAVA_PREFIX/\$LAVA_INSTANCE/instance.conf ]; then
        stop
    else
        # Announce uWSGI becoming online
        logger "LAVA instance (\$LAVA_INSTANCE) uWSGI starting..."
    fi
end script

post-start script
    logger "LAVA instance (\$LAVA_INSTANCE) uWSGI started"
end script

pre-stop script
    logger "LAVA instance (\$LAVA_INSTANCE) uWSGI stopping..."
end script

post-stop script
    logger "LAVA instance (\$LAVA_INSTANCE) uWSGI stopped"
end script

# uWSGI wants to be killed with SIGQUIT to indicate shutdown
# NOTE: this is not supported on Lucid (upstart is too old)
# Currently no workaround exists
kill signal SIGQUIT

# Run uWSGI with instance specific configuration file
script
    # Load instance settings
    . $LAVA_PREFIX/\$LAVA_INSTANCE/instance.conf
    # Simluate virtualenv without spawing anything
    export VIRTUAL_ENV=$LAVA_PREFIX/\$LAVA_INSTANCE
    export PATH=\$VIRTUAL_ENV/bin:\$PATH
    # Start uwsgi, no forks, no daemons, gid/uid changing is managed by uwsgi
    exec $LAVA_PREFIX/\$LAVA_INSTANCE/bin/uwsgi --ini=$LAVA_PREFIX/\$LAVA_INSTANCE/etc/lava-server/uwsgi.ini
end script
LAVA_CONF

        echo "Removing stale upstart file (if needed): lava-celeryd-instance"
        sudo rm -f /etc/init/lava-celeryd-instance.conf

        echo "Creating upstart script for: lava-instance-celeryd"
        sudo sh -c "cat >/etc/init/lava-instance-celeryd.conf" <<LAVA_CONF
author "Zygmunt Krynicki"
description "LAVA Celery worker"

# This is an instance job, there are many possible workers
# each with different instance variable.
instance \$LAVA_INSTANCE

# Stop and start along with the rest of the instance
# start on starting lava-instance
# stop on stopping lava-instance LAVA_INSTANCE=\$LAVA_INSTANCE
# FIXME: upstart + virtualenv + pid tracking + sudo is broken, needs attention, celery is not part of this release

# Respawn the worker if it got hurt
respawn

# Announce workers becoming online
pre-start script
    # Don't start unless the instance configuration file is present
    if [ ! -e $LAVA_PREFIX/\$LAVA_INSTANCE/instance.conf ]; then
        stop
    else
        # Announce uWSGI becoming online
        logger "LAVA instance (\$LAVA_INSTANCE) celery worker starting..."
    fi
end script

post-start script
    logger "LAVA instance (\$LAVA_INSTANCE) celery worker started"
end script

pre-stop script
    logger "LAVA instance (\$LAVA_INSTANCE) celery worker stopping..."
end script

post-stop script
    logger "LAVA instance (\$LAVA_INSTANCE) celery worker stopped"
end script

# Some workers can take a while to exit, this should be enough
kill timeout 360

kill signal SIGTERM

# Run celery daemon 
script
. $LAVA_PREFIX/\$LAVA_INSTANCE/bin/activate
exec sudo -u \$LAVA_INSTANCE VIRTUAL_ENV=\$VIRTUAL_ENV PATH=\$PATH $LAVA_PREFIX/\$LAVA_INSTANCE/bin/lava-server manage celeryd --logfile=$LAVA_PREFIX/\$LAVA_INSTANCE/var/log/lava-celeryd.log --loglevel=info --events
end script

LAVA_CONF

        echo "Creating upstart script for: lava-instance-celerybeat"
        sudo sh -c "cat >/etc/init/lava-instance-celerybeat.conf" <<LAVA_CONF
author "Zygmunt Krynicki"
description "LAVA Celery Scheduler"

# This is an instance job, there are many possible workers
# each with different instance variable.
instance \$LAVA_INSTANCE

# Stop and start along with the rest of the instance
# start on starting lava-instance
# stop on stopping lava-instance LAVA_INSTANCE=\$LAVA_INSTANCE
# FIXME: upstart + virtualenv + pid tracking + sudo is broken, needs attention, celery is not part of this release

# Respawn the worker if it got hurt
respawn

# Announce workers becoming online
pre-start script
    # Don't start unless the instance configuration file is present
    if [ ! -e $LAVA_PREFIX/\$LAVA_INSTANCE/instance.conf ]; then
        stop
    else
        logger "LAVA instance (\$LAVA_INSTANCE) celery scheduler starting..."
    fi
end script

post-start script
    logger "LAVA instance (\$LAVA_INSTANCE) celery scheduler started"
end script

pre-stop script
    logger "LAVA instance (\$LAVA_INSTANCE) celery scheduler stopping..."
end script

post-stop script
    logger "LAVA instance (\$LAVA_INSTANCE) celery scheduler stopped"
end script

# Run celery beat scheduler
script
. $LAVA_PREFIX/\$LAVA_INSTANCE/bin/activate
exec sudo -u \$LAVA_INSTANCE VIRTUAL_ENV=\$VIRTUAL_ENV PATH=\$PATH $LAVA_PREFIX/\$LAVA_INSTANCE/bin/lava-server manage celerybeat --logfile=$LAVA_PREFIX/\$LAVA_INSTANCE/var/log/lava-celerybeat.log --loglevel=info --pidfile=$LAVA_PREFIX/\$LAVA_INSTANCE/run/lava-celerybeat.pid --schedule=$LAVA_PREFIX/\$LAVA_INSTANCE/var/lib/lava-celery/celerybeat-schedule
end script
LAVA_CONF

        echo "Creating upstart script for: lava-instance-celerycam"
        sudo sh -c "cat >/etc/init/lava-instance-celerycam.conf" <<LAVA_CONF
author "Zygmunt Krynicki"
description "LAVA Celery Camera (worker snapshot service)"

# This is an instance job, there are many possible workers
# each with different instance variable.
instance \$LAVA_INSTANCE

# Stop and start along with the rest of the instance
# start on starting lava-instance
# stop on stopping lava-instance LAVA_INSTANCE=\$LAVA_INSTANCE
# FIXME: upstart + virtualenv + pid tracking + sudo is broken, needs attention, celery is not part of this release

# Respawn the worker if it got hurt
respawn

# Announce workers becoming online
pre-start script
    # Don't start unless the instance configuration file is present
    if [ ! -e $LAVA_PREFIX/\$LAVA_INSTANCE/instance.conf ]; then
        stop
    else
        logger "LAVA instance (\$LAVA_INSTANCE) celery cam starting..."
    fi
end script

post-start script
    logger "LAVA instance (\$LAVA_INSTANCE) celery cam started"
end script

pre-stop script
    logger "LAVA instance (\$LAVA_INSTANCE) celery cam stopping..."
end script

post-stop script
    logger "LAVA instance (\$LAVA_INSTANCE) celery cam stopped"
end script

# Run celery camera
script
. $LAVA_PREFIX/\$LAVA_INSTANCE/bin/activate
exec sudo -u \$LAVA_INSTANCE VIRTUAL_ENV=\$VIRTUAL_ENV PATH=\$PATH $LAVA_PREFIX/\$LAVA_INSTANCE/bin/lava-server manage celerycam --logfile=$LAVA_PREFIX/\$LAVA_INSTANCE/var/log/lava-celerycam.log --loglevel=info --pidfile=$LAVA_PREFIX/\$LAVA_INSTANCE/run/lava-celerycam.pid
end script
LAVA_CONF

        echo "Creating upstart script for: lava-instance-scheduler"
        sudo sh -c "cat >/etc/init/lava-instance-scheduler.conf" <<LAVA_CONF
author "Zygmunt Krynicki"
description "LAVA Scheduler"

# This is an instance job, there are many possible workers
# each with different instance variable.
instance \$LAVA_INSTANCE

# Stop and start along with the rest of the instance
start on starting lava-instance
stop on stopping lava-instance LAVA_INSTANCE=\$LAVA_INSTANCE

# Respawn the worker if it got hurt
respawn

# Announce workers becoming online
pre-start script
    # Don't start unless the instance configuration file is present
    if [ ! -e $LAVA_PREFIX/\$LAVA_INSTANCE/instance.conf ]; then
        stop
    else
        . $LAVA_PREFIX/\$LAVA_INSTANCE/instance.conf
        # We only prevent the scheduler from running if
        # LAVA_SCHEDULER_ENABLED is set and set to 'no', to be most
        # compatible with the previous behaviour of always running the
        # scheduler.
        if [ "x\$LAVA_SCHEDULER_ENABLED" = "xno" ]; then
            stop
        else
            logger "LAVA instance (\$LAVA_INSTANCE) scheduler starting..."
        fi
    fi
end script

post-start script
    logger "LAVA instance (\$LAVA_INSTANCE) scheduler started"
end script

pre-stop script
    logger "LAVA instance (\$LAVA_INSTANCE) scheduler stopping..."
end script

post-stop script
    logger "LAVA instance (\$LAVA_INSTANCE) scheduler stopped"
end script

script
    # Load instance settings
    . $LAVA_PREFIX/\$LAVA_INSTANCE/instance.conf
    # Simluate virtualenv without spawing anything
    export VIRTUAL_ENV=$LAVA_PREFIX/\$LAVA_INSTANCE
    export PATH=\$VIRTUAL_ENV/bin:\$PATH
    # Start LAVA scheduler, it runs as root in this release
    exec $LAVA_PREFIX/\$LAVA_INSTANCE/bin/lava-server manage --instance-template=$LAVA_PREFIX/{instance}/etc/lava-server/{{filename}}.conf --instance=\$LAVA_INSTANCE scheduler --logfile=$LAVA_PREFIX/\$LAVA_INSTANCE/var/log/lava-scheduler.log --loglevel=info
end script
LAVA_CONF

        # Store setup version
        echo $LAVA_SETUP_REQUIRED_VERSION > $LAVA_PREFIX/.setup
        echo "Setup complete, you can now install LAVA"
    else
        echo "This step has been already performed"
    fi
}


die() {
    echo "$1"
    exit 1
}


_banner() {
    echo "===================="
    echo "LAVA Deployment Tool"
    echo "===================="
    echo
}


cmd_install() {
    export LAVA_INSTANCE=$1
    export LAVA_BUNDLE=$2

    check_min_version
    _banner

    if [ -z "$LAVA_INSTANCE" ]; then
        echo "You need to pass the name of the instance to create as first argument"
        return
    fi

    if [ -z "$LAVA_BUNDLE" ]; then
        echo "You need to pass the name of the bundle to use as second argument"
        return
    fi

    # Sanity checking, ensure that instance does not exist yet
    if [ -d "$LAVA_PREFIX/$LAVA_INSTANCE" ]; then
        echo "Instance $LAVA_INSTANCE already exists"
        return
    fi

    # Configure everything first (get all the answers)
    _configure "$LAVA_INSTANCE"
    # Roll the installation
    _install
}


cmd_upgrade() {
    export LAVA_INSTANCE=$1
    export LAVA_BUNDLE=$2

    check_min_version
    _banner

    if [ -z "$LAVA_INSTANCE" ]; then
        echo "You need to pass the name of the instance to create as first argument"
        return
    fi

    if [ -z "$LAVA_BUNDLE" ]; then
        echo "You need to pass the name of the bundle to use as second argument"
        return
    fi

    # Sanity checking, ensure that instance exist
    if [ \! -d "$LAVA_PREFIX/$LAVA_INSTANCE" ]; then
        echo "Instance $LAVA_INSTANCE does not exist"
        return
    fi

    _load_configuration "$LAVA_INSTANCE"
    install_app || die "Failed to upgrade application code"
    install_config_app || die "Failed to run post-upgrade configuration"
}


cmd_remove() {
    LAVA_INSTANCE=${1:-dev}

    _banner

    # Sanity checking, ensure that instance exists
    if [ \! -d "$LAVA_PREFIX/$LAVA_INSTANCE" ]; then
        echo "Instance $LAVA_INSTANCE does not exist"
        return
    fi

    _load_configuration "$LAVA_INSTANCE"

    echo "*** WARNING ***" 
    echo "You are about to IRREVERSIBLY DESTROY the instance $LAVA_INSTANCE"
    echo "There is no automatic backup, there is no way to undo this step"
    echo "*** WARNING ***" 

    echo "We will remove system user $LAVA_SYS_USER"
    echo "We will remove PostgreSQL database $LAVA_DB_NAME"
    echo "We will remove PostgreSQL user: $LAVA_DB_USER"
    echo "We will remove everything in $LAVA_PREFIX/$LAVA_INSTANCE"
    echo "We will remove the apache site $LAVA_INSTANCE.conf"
    echo "We will remove the RabbitMQ user: $LAVA_RABBIT_USER"
    echo "We will remove the RabbitMQ vhost: $LAVA_RABBIT_VHOST"
    echo
    read -p "Type DESTROY to continue: " RESPONSE
    test "$RESPONSE" = 'DESTROY' || return

    logger "Removing LAVA instance $LAVA_INSTANCE"

    set -e
    set -x
    # Remove everything 
    sudo stop lava-instance LAVA_INSTANCE=$LAVA_INSTANCE || true
    sudo rm -f "/etc/apache2/sites-available/$LAVA_INSTANCE.conf" || true
    sudo rm -f "/etc/apache2/sites-enabled/$LAVA_INSTANCE.conf" || true
    sudo rm -f "/etc/apache2/conf.d/$LAVA_INSTANCE.conf" || true
    sudo -u postgres dropdb "$LAVA_DB_NAME" || true
    sudo -u postgres dropuser "$LAVA_DB_USER" || true
    sudo rabbitmqctl delete_user "$LAVA_RABBIT_USER" || true
    sudo rabbitmqctl delete_vhost "$LAVA_RABBIT_VHOST" || true
    sudo userdel "$LAVA_SYS_USER" || true
    sudo rm -rf "$LAVA_PREFIX/$LAVA_INSTANCE" || true
    set +x
    set +e
}


cmd_restore() {
    LAVA_INSTANCE=${1}

    check_min_version
    set -e

    # Sanity checking, ensure that instance exists
    if [ \! -d "$LAVA_PREFIX/$LAVA_INSTANCE" ]; then
        echo "Instance $LAVA_INSTANCE does not exist"
        return
    fi

    local SNAPSHOT_ID=${2}
    local SNAPSHOT_PATH="$LAVA_ROOT/backups/$LAVA_INSTANCE/$SNAPSHOT_ID"
    local SNAPSHOT_PATH_ALT="$LAVA_ROOT/backups/$SNAPSHOT_ID"

    if [ -e "$SNAPSHOT_PATH" ]; then
        SNAPSHOT="$SNAPSHOT_PATH"
    else
        if [ -e "$SNAPSHOT_PATH_ALT" ]; then
            SNAPSHOT="$SNAPSHOT_PATH_ALT"
        else
            echo "Cannot find snapshot called '$SNAPSHOT_ID'"
            echo "It should be in $SNAPSHOT_PATH or $SNAPSHOT_PATH_ALT (alternative)"
            return
        fi
    fi

    _load_configuration "$LAVA_INSTANCE"

    db_snapshot="$SNAPSHOT/database.dump"
    files_snapshot="$SNAPSHOT/files.tar.gz"

    if [ \! -f "$db_snapshot" -o \! -f "$files_snapshot" ]; then
        echo "$SNAPSHOT does not look like a complete snapshot"
        return
    fi

    echo "Are you sure you want to restore instance $LAVA_INSTANCE from"
    echo "$SNAPSHOT_ID?  This will DESTROY the existing state of $LAVA_INSTANCE"
    echo
    read -p "Type RESTORE to continue: " RESPONSE
    test "$RESPONSE" = 'RESTORE' || return

    # Load database configuration
    . $LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/default_database.conf

    # Substitute missing defaults for IP-based connection this works around a bug
    # in postgresql configuration on default Ubuntu installs and allows us to use
    # the ~/.pgpass file.
    test -z "$dbport" && dbport=5432
    test -z "$dbserver" && dbserver=localhost

    if [ "$dbserver" != "localhost" ]; then
        echo "You can only run restore on the host on which postgres is running"
        return
    fi

    set -x

    # Stop the instance
    sudo stop lava-instance LAVA_INSTANCE=$LAVA_INSTANCE || true

    sudo -u postgres dropdb \
        --port $dbport \
        $dbname || true
    sudo -u postgres createdb \
        --encoding=UTF-8 \
        --owner=$dbuser \
        --port $dbport \
        --no-password \
        $dbname
    sudo -u postgres pg_restore \
        --exit-on-error --no-owner \
        --port $dbport \
        --role $dbuser \
        --dbname $dbname \
        $SNAPSHOT/database.dump > /dev/null

    sudo rm -rf $LAVA_PREFIX/$LAVA_INSTANCE/var/lib/lava-server/
    mkdir -p $LAVA_PREFIX/$LAVA_INSTANCE/var/lib/lava-server/
    tar \
        --extract \
        --gzip \
        --directory $LAVA_PREFIX/$LAVA_INSTANCE/var/lib/lava-server/ \
        --file "$files_snapshot"

    # Allow instance to write to media directory
    sudo chgrp -R $LAVA_SYS_USER $LAVA_PREFIX/$LAVA_INSTANCE/var/lib/lava-server/
    sudo chmod -R g+rwXs $LAVA_PREFIX/$LAVA_INSTANCE/var/lib/lava-server/

    echo "Done"
}


cmd_backup() {
    LAVA_INSTANCE=${1:-dev}

    check_min_version
    set -e

    # Sanity checking, ensure that instance exists
    if [ \! -d "$LAVA_PREFIX/$LAVA_INSTANCE" ]; then
        echo "Instance $LAVA_INSTANCE does not exist"
        return
    fi

    # Load database configuration
    . $LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/default_database.conf

    # Substitute missing defaults for IP-based connection this works around a bug
    # in postgresql configuration on default Ubuntu installs and allows us to use
    # the ~/.pgpass file.
    test -z "$dbserver" && dbserver=localhost
    test -z "$dbport" && dbport=5432

    export PGPASSWORD=$dbpass

    snapshot_id=$(TZ=UTC date +%Y-%m-%dT%H-%M-%SZ)

    echo "Making backup with id: $snapshot_id"

    destdir="$LAVA_ROOT/backups/$LAVA_INSTANCE/$snapshot_id"

    mkdir -p "$destdir"

    set -x

    echo "Creating database snapshot..."

    pg_dump \
        --no-owner \
        --format=custom \
        --host=$dbserver \
        --port=$dbport \
        --username=$dbuser \
        --no-password $dbname \
        --schema=public \
        > "$destdir/database.dump"

    echo "Backing up instance configuration..."
    tar --create \
        --gzip \
        --directory $LAVA_PREFIX/$LAVA_INSTANCE/ \
        --file "$destdir/etc.tar.gz" \
        etc

    echo "Creating file repository snapshot..."
    # tar exiting with code 1 means that the files changed under us as
    # tar was running.  As this is to be expected, we suppress that
    # exit code.  Exit code 2 means something bad happened, and we
    # should stop.
    GZIP='--rsyncable' tar \
        --create \
        --ignore-failed-read \
        --warning=no-file-changed \
        --gzip \
        --directory $LAVA_PREFIX/$LAVA_INSTANCE/var/lib/lava-server/ \
        --file "$destdir/files.tar.gz" \
        . || [ $? == 1 ]
    #   ^ There is a DOT HERE don't remove it

    ln -sfT "$destdir" "$LAVA_ROOT/backups/$LAVA_INSTANCE/latest"

    echo "Done"
}


cmd_manage() {
    LAVA_INSTANCE=${1:-dev}
    test -n '$1' && shift

    # Sanity checking, ensure that instance exists
    if [ \! -d "$LAVA_PREFIX/$LAVA_INSTANCE" ]; then
        echo "Instance $LAVA_INSTANCE does not exist"
        return
    fi
    _load_configuration "$LAVA_INSTANCE"

    # Enable virtualenv
    . $LAVA_PREFIX/$LAVA_INSTANCE/bin/activate

    set -x
    lava-server manage \
        --instance-template=$LAVA_ROOT/instances/{instance}/etc/lava-server/{{filename}}.conf \
        --instance=$LAVA_INSTANCE \
        "$@"
    set +x
}


cmd_bundle() {
    LAVA_REQUIREMENT=${1:-requirements/requirements.txt}
    LAVA_BUNDLE=${2:-lava.pybundle}
    local step
    for step in $LAVA_INSTALL_STEPS; do
        defaults_$step
    done
    LAVA_FULL_REQUIREMENT=$(mktemp)
    for step in $LAVA_INSTALL_STEPS; do
        pkglist_$step >> "$LAVA_FULL_REQUIREMENT"
    done
    set -x
    pip bundle "$LAVA_BUNDLE" $PIP_PROXY_OPTION --timeout=30 --use-mirrors --requirement="$LAVA_FULL_REQUIREMENT" || die "Failed to create bundle"
    set +x
    rm -f "$LAVA_FULL_REQUIREMENT"
}

cmd_preview () {
    export LAVA_INSTANCE=$1
    export LAVA_BUNDLE=$2

    check_min_version

    _bundle="$(readlink -f $LAVA_BUNDLE)"
    _tmpdir="$(mktemp -d)"

    trap "rm -rf \"${_tmpdir}\"" EXIT

    cd "${_tmpdir}"

    unzip -qc "${_bundle}" pip-manifest.txt | grep -v '^#' | tr '[A-Z]' '[a-z]' | sort > bundle-versions.txt
    $LAVA_PREFIX/$LAVA_INSTANCE/bin/pip freeze | tr '[A-Z]' '[a-z]' | sort > installed-versions.txt

    $(dirname $(readlink -f "$0"))/_compare_manifests.py installed-versions.txt bundle-versions.txt
}

is_vhost(){
    export LAVA_INSTANCE=$1
    vhost_conf="/etc/apache2/sites-enabled/$LAVA_INSTANCE.conf"
    singleip_conf="/etc/apache2/conf.d/${LAVA_INSTANCE}.conf"
    if [ -f ${vhost_conf} ]; then
        echo 'vhost'
    elif [ -f ${singleip_conf} ]; then
        echo 'location'
    else
        echo 'unknown'
    fi
}


cmd_list(){

    _banner

    INSTANCES=`ls $LAVA_PREFIX`
    if [ "X${INSTANCES}" = "X" ]; then
        echo "NO INSTANCES"
        return
    else
        echo "================================"
        echo "INSTANCE_NAME     VHOST/LOCATION"
        echo "================================"
    fi
    for instance in ${INSTANCES}; do
        is_vhost_value=`is_vhost ${instance}`
        printf "%s\t%s\n" ${instance} ${is_vhost_value}
    done
    echo "================================"
}


toggle_instance() {
    export LAVA_INSTANCE=$1
    export TARGET=${2:vhost}

    if [ -z "$LAVA_INSTANCE" ]; then
        echo "You need to pass the name of the instance to create as first argument"
        return
    fi

    # Sanity checking, ensure that instance exist
    if [ \! -d "$LAVA_PREFIX/$LAVA_INSTANCE" ]; then
        echo "Instance $LAVA_INSTANCE does not exist"
        return
    fi

    settings_file="$LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/settings.conf"
    single_conf="$LAVA_PREFIX/$LAVA_INSTANCE/etc/apache2/conf.d/${LAVA_INSTANCE}.conf"
    reload_file="$LAVA_PREFIX/$LAVA_INSTANCE/etc/lava-server/uwsgi.reload"

    if [ "x${TARGET}" = "xvhost" ]; then
        sudo rm /etc/apache2/conf.d/${LAVA_INSTANCE}.conf
        sed -i "s/    \"MEDIA_URL\": \"\/${LAVA_INSTANCE}-media\/\",/    \"MEDIA_URL\": \"\/media\/\",/" ${settings_file} 
        sed -i "s/    \"STATIC_URL\": \"\/${LAVA_INSTANCE}-static\/\",/    \"STATIC_URL\": \"\/static\/\",/" ${settings_file}
        sed -i "s/    \"LOGIN_REDIRECT_URL\": \"\/${LAVA_INSTANCE}\",/    \"LOGIN_REDIRECT_URL\": \"\/\",/" ${settings_file}
        touch ${reload_file}
        sudo a2ensite $LAVA_INSTANCE.conf
        if [ -e /etc/apache2/sites-enabled/000-default ]; then
            sudo a2dissite 000-default || true
        fi
        return 0
    elif [ "x${TARGET}" = "xlocation" ]; then
        if [ \! -e "${single_conf}" ];then
            generate_conf_d_file
        fi
        
        sudo a2dissite $LAVA_INSTANCE.conf
        if [ "`ls -A /etc/apache2/sites-enabled/`" = "" ]; then
            sudo a2ensite 000-default
        fi

        sudo ln -s ${single_conf} /etc/apache2/conf.d/${LAVA_INSTANCE}.conf
        sed -i "s/    \"MEDIA_URL\": \"\/media\/\",/    \"MEDIA_URL\": \"\/${LAVA_INSTANCE}-media\/\"\,/" ${settings_file} 
        sed -i "s/    \"STATIC_URL\": \"\/static\/\",/    \"STATIC_URL\": \"\/${LAVA_INSTANCE}-static\/\",/" ${settings_file}
        sed -i "s/    \"LOGIN_REDIRECT_URL\": \"\/\",/    \"LOGIN_REDIRECT_URL\": \"\/${LAVA_INSTANCE}\",/" ${settings_file}
        touch ${reload_file}
        return 0
    else
        echo 'target must be specified with "site" or "singleip"'
        return 1
    fi
}


cmd_toggle(){
    LAVA_INSTANCE=$1
    TARGET=${2:vhost}
    _banner
    
    toggle_instance ${LAVA_INSTANCE} ${TARGET}
    if [ $? -eq 0 ]; then
        sudo service apache2 restart
    fi
}


cmd_toggle_all(){
    TARGET=${1:vhost}

    _banner
   
    if [ "X${TARGET}" != "Xvhost"  -a  "X${TARGET}" != "Xlocation" ]; then
        echo 'Please specify the target with "vhost" or "location"'
        return 1
    fi

    INSTANCES=`ls $LAVA_PREFIX`
    if [ "X${INSTANCES}" = "X" ]; then
        return
    fi
    need_restart_apache=false
    for instance in ${INSTANCES}; do
        is_vhost_value=`is_vhost ${instance}`
        if [ "X${TARGET}" = "X${is_vhost_value}" ]; then
            continue
        fi
        if [ "X${TARGET}" = "Xunknown" ]; then
            continue
        fi
        printf "Start to change instance(%s) to %s\n" ${instance} ${TARGET}
        toggle_instance ${instance} ${TARGET}
        if [ $? -eq 0 ]; then
            need_restart_apache=true
            printf "Change instance(%s) to %s successfully\n" ${instance} ${TARGET}
        else
            printf "Change instance(%s) to %s failed\n" ${instance} ${TARGET}
        fi
    done
    if ${need_restart_apache}; then
        sudo service apache2 restart
    fi
}


main() {
    os_check
    uid_check
    if [ $LAVA_SUPPORTED = 0 ]; then
        echo "LAVA is not supported on this system"
        echo "------------------------------------"
        echo "Please report a bug on lava-deployment-tool"
        echo "https://bugs.launchpad.net/lava-deployment-tool/+filebug"
        echo
        echo "Please provide the following information"
        echo 
        lsb_release -a
        exit 1
    fi

    if [ -n "$1" ]; then
        cmd="$1"
        shift
    else
        cmd=help
    fi
    case "$cmd" in
        ^$|help)
            echo "Usage: ${__FILE_NAME__} <command> [options]"
            echo
            echo "Key commands:"
            echo "    setup   - prepare machine for LAVA (prerequisites)"
            echo "              (do this once before trying out others)"
            echo " working with instances:"
            echo "    list    - list all instances installed"
            echo "    bundle  - create a bundle in preparation for installing"
            echo "              or updating"
            echo "    install - install LAVA instance"
            echo "    upgrade - upgrade LAVA instance"
            echo "    remove  - remove LAVA instance (undoes install)"
            echo "    toggle  - toggle one LAVA instance between being"
            echo "            - referenced by the location (aka "
            echo "              insance name) or by the vhost"
            echo "              * vhost site: the instance is configured with"
            echo "                  VirtualHost directive of apache"
            echo "                  (ex. http://vhost.example.com)"
            echo "              * location site: the instance is configured"
            echo "                  with Location directive of apache"
            echo "                  (ex. http://localhost/instance_name)"
            echo "            - With the location site we can deploy multiple"
            echo "            - instances on a single IP machine, while with"
            echo "            - the vhost site we need have multiple hostnames"
            echo "            - or IPs for deploying multiple instances"
            echo "            - run ${__FILE_NAME__} toggle \$instance [location|vhost]"
            echo "    toggle_all  - toggle all LAVA instances one time between"
            echo "            - used as location site or used as vhost site"
            echo "            - like toggle command"
            echo "            - run ${__FILE_NAME__} toggle_all [location|vhost]"
            echo " working with data:"
            echo "    backup  - backup your data"
            echo "    restore - restore earlier backup (removes current data)"
            echo " working at lower level:"
            echo "    manage  - run lava-server management commands"
            echo
            echo "See the README file for instructions"
            ;;
        setup)
            cmd_setup "$@"
            ;;
        install|upgrade|remove|preview)
            cmd_$cmd "$@" # 2>&1 | tee "$cmd-log-for-instance-$LAVA_INSTANCE.log"
            ;;
        manage)
            cmd_manage "$@"
            ;;
        backup)
            cmd_backup "$@"
            ;;
        restore)
            cmd_restore "$@"
            ;;
        install_*)
            set -x
            set -e
            _load_configuration "$@"
            $cmd
            set +x
            set +e
            ;;
        bundle)
            cmd_bundle "$@"
            ;;
        toggle)
            cmd_toggle "$@"
            ;;
        toggle_all)
            cmd_toggle_all "$@"
            ;;
        list)
            cmd_list "$@"
            ;;
        version)
            echo "LAVA Deployment Tool, version $LAVA_DEPLOYMENT_TOOL_VERSION."
            ;;
        *)
            echo "Unknown command: $cmd, try help"
            exit 1
            ;;
    esac
}

__FILE_NAME__=`basename ${0}`
main "$@"
